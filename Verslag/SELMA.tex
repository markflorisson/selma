\documentclass[]{article}

\title{SELMA}
\author{ 
Vonk, J\\
s0132778\\
Matenweg 75-201\\
\\
Florisson, M\\
s0165972\\
Box Calslaan 60-30}

\usepackage{listings}
\usepackage{lscape}
\usepackage{color}
\usepackage[pdftex,bookmarks=true]{hyperref}
\usepackage{hyperref}
\usepackage{verbatim}
% \usepackage[T1]{fontenc}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\begin{document}

\lstdefinestyle{ANTLR}
	{frame=shadowbox, breaklines=true,basicstyle=\footnotesize}
\lstdefinestyle{SELMA}
	{frame=shadowbox, breaklines=true,basicstyle=\small}
\lstdefinestyle{JAVA}
	{frame=shadowbox, language=Java, breaklines=true,basicstyle=\footnotesize}
\lstdefinestyle{ANTLRfile}
	{frame=LB, breaklines=true, basicstyle=\scriptsize, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	
\lstdefinestyle{SELMAfile}
	{frame=LB, breaklines=true, basicstyle=\scriptsize, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	
\lstdefinestyle{JAVAfile}
	{frame=LB, language=Java, breaklines=true, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	
\lstdefinestyle{JVMfile}
	{frame=LB, breaklines=true, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	

\newcommand{\todo}[1]{\marginpar{\fcolorbox{red}{yellow}{\textbf{#1}}}}



\begin{titlepage}
\maketitle 
\end{titlepage}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\tableofcontents{}

\newpage
\section{Inleiding}
%Korte beschrijving van de practicumopdracht.
Voor vertalerbouw dient als eindopdracht een eigen taal geschreven te worden. Deze taal dient een expression-language te zijn, dit is een taal die geen statements, maar enkel expressies kent. Alles wat je dus aanroept zal een waarde teruggeven.\\
Voor deze zelfbedachte taal dient een parser en lexer geschreven te worden, een checker en een compiler. Hierbij dient een verslag met een uitgebreide beschrijving van de taal en een goede kijk op hoe alles onder de motorkap werkt. Ook moet er een bewijs worden geleverd dat de taal werkt, dit kan door een testprogramma te schrijven dat tamelijk uitgebreid is en te kijken of dit werkt naar behoren. (exhaustive testing) \\
Hoe uitgebreid de te definieren taal wordt is aan de studenten zelf - dit is echter terug te zien in het te behalen cijfer.\\
Voor onze taal, SELMA, hebben wij gekozen voor het volgende:
\todo{Klopt?}
\begin{itemize}
\item Basic Expression Language
\item If- \& while-statements
\item Ondersteunen van functies
\item Compileren naar JVM-code in plaats van TAM-code
\end{itemize}

Onze taal heet SELMA. Een naam aan een taal geven is lastig, zo waren er een aantal andere opties zoals: SMEF of Taal voor Vertalerbouw (TV).
SELMA staat voor Simpel Expression Language. Nu moest de afkorting wat meer zeggen dus kozen we voor de meisjesnaam SELMA, alleen maar omdat een afkorting vinden voor SELDERIE wel heel veel werk is.\\
Gelukkig heet onze taal dus geen SELDERIE, maar SELMA:\\
Waarbij de MA voor Minor Adjustments stond, we hebben inmiddels zoveel werk eraan gehad dat "Minor" dat geen eer meer aan doet. \\
Dus met gepaste trots presenteren wij u SELMA:\\
Simple Expression Language Met Augurk\\
Vanaf nu enkel nog naar te verwijzen als SELMA.\\

\newpage
\section{Beknopte beschrijving}
%van de programmeertaal (maximaal een A4-tje).
Onze taal is gemaakt naar de gegeven instructies van de practicumhandleiding en alles is of een expressie of declaration in deze taal. Bij sommige expressies is het echter niet mogelijk een resultaat te geven, hier kunnen die expressies niet anders dan een void-resultaat retouneren, wat ze effectief een statement maakt. De structuur van de taal en de keywords lijken qua layout op een hybride tussen C en Pascal. \\
De volledige taal is LL(1) wij hebben hierdoor vooral tijdens het ontwerpen goed moeten nadenken hoe we de taal zo logisch mogelijk opbouwden zodat de parser er mee uit de voeten kon. Eventueel is er de mogelijkheid om lokaal 1 stap verder te kijken, wij hebben dit echter niet nodig gehad omdat wij voldoende keywords hebben gebruikt, zoals voor een functie een @ zetten - en we in de parser bewust rekening hebben gehouden met de LL(1) limitatie.\\
\todo{@?}
\\
SELMA compileerde in eerste instantie naar TAM, op de cd is een fragment van deze code te zien. We hebben echter besloten dat het mooier was om JVM te gebruiken, niet zo zeer uit praktisch oogpunt, maar meer omdat JVM-bytecode ook door "echte" talen wordt gebruikt en omdat het een pluspunt is in de eindbeoordeling.\\
Op het moment dat we besloten om te schakelen waren we blij dat we haddne gekozen voor het gebruik van stringTemplates bij de codegeneratie, dit heeft ons wat werk gescheeld. En technisch gezien zouden we zo een extra compiler naar TAM-code erbij kunnen doen, aangezien er geen andere reden is dan "omdat het kan" hebben we onszelf die moeite bespaard.\\
\\
Lees verder - of probeer eens een testprogramma te compileren in SELMA - om te leren hoe de vork nou precies in de steel zit met deze taal.\\
\\
\textit{- Mark \& Jeroen}


\newpage
\section{Problemen en oplossingen}
uitleg over de wijze waarop je de problemen die je bent tegenge-
komen bij het maken van de opdracht hebt opgelost (maximaal twee A4-tjes).

\newpage
\section{Syntax, context-beperkingen en semantiek}

%van de taal met waar nodig nadere uitleg over de
%betekenis. Geef de beschrijving bij voorkeur in dezelfde terminologie als die gebruikt is bij
%de beschrijving van Triangle in Watt \& Brown (hoofdstuk 1 en appendix B).

\subsection{Lexer - terminals}
Om de code te kunnen parsen zal deze eerst door de lexer moeten gaan. Hier definieren wij een aantal terminal symbolen. Dit is een eindige set van een aantal symbolen of woorden, de lexer zal deze herkennen. Mits ze in de juiste volgorde worden gebruikt krijg je taalconstructies die de parser vervolgens weer begrijpt. We hebben een aantal speciale terminals die zijn opgebouwd uit meerdere karakters bijvoorbeeld. Deze vormen de lexicon. En een drietal terminals zonder textuele vorm. Deze zijn enkel voor de interne boekhouding van de parser.
\\
\begin{lstlisting}[style=ANTLR]
CHARV		APOSTROPHE LETTER APOSTROPHE;
BOOLEAN		(TRUE | FALSE);
ID		LETTER (LETTER | DIGIT)*;
NUMBER		DIGIT+;
	
DIGIT		('0'..'9');
LOWER		('a'..'z');
UPPER		('A'..'Z');
LETTER		(LOWER | UPPER);
TRUE		'true';
FALSE		'false';

UMIN;
UPLUS;
COMPOUND;			
\end{lstlisting}

\newpage 

Verder zijn er nog de 'gewone' terminals. Te verdelen in keywords, tokens en operators. Keywords geven aan dat er een bepaalde actie gedaan wordt, zoals een variabele declareren of een if statement. Tokens zijn er om de taal iets meer structuur te geven, denk aan comma's tussen de variabelen. En operators zijn bewerkingen die je kunt uitvoeren op 1 of meer expressies.
\\
\begin{lstlisting}[style=ANTLR]
	Tokens			Keywords
	
COLON		':';	PRINT		'print';
SEMICOLON	';';	READ		'read';
LPAREN		'(';	VAR		'var';
RPAREN		')';	CONST		'const';
LCURLY		'{';	INT		'integer';
RCURLY		'}';	BOOL		'boolean';
COMMA		',';	CHAR		'character';
EQ		'=';	BEGIN		'begin';
APOSTROPHE	''';	END		'end.';
			IF		'if';
			THEN		'then';
			ELSE		'else';
			FI		'fi';
			WHILE		'while';
	Operators	DO		'do';
			OD		'od';
NOT		'!';	PROC		'procedure';
MULT		'*';	FUNC		'function';
DIV		'/';
MOD		'%';
PLUS		'+';
MINUS		'-';
RELS		'<';
RELSE		'<=';
RELGE		'>=';
RELG		'>';
RELE		'==';
RELNE		'<>';
AND		'&&';
OR		'||';
BECOMES		':=';
\end{lstlisting}
\newpage

\subsection{De basis - Programma}
De basis van het programma geeft een aantal restricties op aan de taal.
Allereerst is er het programma, dit bestaat uit een (zeer grote) compoundexpression waarna het programma stopt (End Of File). Deze wordt hier herschreven. Een compoundexpression is uiteindelijk opgebouwd uit een serie declaraties en statements, gescheiden door een semicolon. Hier is te zien dat het programma uit minimaal 1 expressie bestaat, dat declaraties en expressies door elkaar gebruikt mogen worden en dat het laatste statement in een programma altijd een expressie is.
\lstinputlisting[style=ANTLR,linerange={100-111}]{../g-files/SELMA.g}

\subsection{Expression\_statement}
Dit is een speciale tussenstap voor de interne boekhouding. Na elke semicolumn zal de mogelijk resterende waarde van de stack worden gepopped. Dit maakt dat er niet aan het eind van ons programma een hoop troep op de stack staat. Voorwaarde is wel dat er wordt bijgehouden wanneer een expression van het type void is, dan hoeft er namelijk niet gepopped te worden.
\lstinputlisting[style=ANTLR,linerange={146-148}]{../g-files/SELMA.g}

\subsection{Declaraties en types}
SELMA kent twee soorten waarden-declaraties, variabelen en constanten. SELMA staat toe om per declaratie meerdere identifiers te definieren. Bij de declaratie dien je het type van de te declareren waarde mee te geven. En bij een constante dien je uiteraard een waarde mee te geven.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={115-129}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Het gegeven type dient bij de constante overeen te komen met het type van de gegeven waarde.
\item Identifiers mogen niet eerder gedeclareerd zijn, in de huidige of bovenliggende scope.
\end{itemize}
\subsubsection{Semantiek}
Er zal ruimte gereserveerd worden voor de variabele en het adres wordt onthouden. Voor een constante geldt hetzelfde behalve dat dan ook direct de desbetreffende waarde op dat adres wordt gezet. Op het moment dat elders in het programma een verwijzing is naar deze gedeclareerde dan zal deze variabele of constante geladen worden.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
var i, x: integer;
const c: char = 'g';
const b,t: boolean = true;
\end{lstlisting}

\subsection{Functiedeclaratie}
SELMA kent ook nog een functie declaratie. Deze valt logischerwijs ook onder de declaraties. De declaratie van een functie dient altijd voor het gebruik te komen. Een functie kan als een soort procedure worden gebruikt door geen return-type op te geven. Het return-type wordt dan automatisch void. Dit hebben we express gedaan, we willen het namelijk altijd een functie noemen, aangezien procedures niet echt een plek hebben binnen een expressietaal.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={122-122,131-134}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De naam van de functie moet uniek zijn als functienaam, er mag wel een variabele of constante bestaan met die naam.
\item De opgegeven identifiers moeten allemaal een andere naam hebben, ze hoeven echter niet uniek te zijn binnen het programma aangezien ze in een aparte scope staan.
\item Het type van de expressie na het returntype dient hetzelfde te zijn als type.
\end{itemize}
\subsubsection{Semantiek}
Het adres waar deze functie staat wordt opgeslagen. Daarna komt de code van de functie. Aan het einde van de functie zal eventueel een result op de stack worden gezet en wordt het adres dat aan het begin is gegeven aangeroepen om weer terug te komen op de plek waar de functie werdt aangeroepen.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
function foo() {
	6*7;
}
function foo(awesome,less:boolean;bar:integer;): integer {
	var i: integer;
	
	if (awesome;) then
		i := 42;
	else
		i := 2;
	fi;
	
	return i;
}
\end{lstlisting}


\subsection{Expressies - assignment}
De expressies zijn ingedeeld in verschillende niveaus, dit om te zorgen dat ze in de juiste volgorde worden uitgevoerd. Zo willen we dat 6+3*12 niet 108 is maar 42, niet alleen om dat 42 een mooier getal is, maar voornamelijk omdat het fijn is als de taal voldoet aan de conventionele rekenregels. \\
Het hoogste niveau is de assignment.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={151-157}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_arithmetic moet een identifier worden, in het eind, aangezien dat het enige is waaraan je een waarde kunt toekennen
\item deze identiefier moet dan verwijzen naar een geldige variabele
\item het type van expression en expression\_arithmetic moet hetzelfde zijn
\item expression is van het type van expr\_assignment
\item expr\_assignment is van het type van expr\_arithmetic 
\end{itemize}
\subsubsection{Semantiek}
De waarde van expression zal worden toegekend aan het linker deel van de assignment.
Tevens gaat de waarde van de hele expressie op de stack, zo is er een asignement met meerdere identifiers mogelijk.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
foo := 7*6;
foo := bar := 7*6;
\end{lstlisting}

\subsection{Expressies - OR}
De Of-operator is de laagste operator in het rijtje, vandaar dat deze bovenin de structuur zit.
\\
NB: expr\_al1 staat voor "expression arithmetic level 1"
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={159-165}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Als expr\_al1 enkel uit 1 expr\_al2 bestaat dan zijn er geen restricties
\item In de andere gevallen dienen alle expr\_al2 van het type boolean te zijn.
\item het type van expr\_arithmetic is het type van expr\_al1
\item als exp\_1 == expr\_al2 dan is het type van expr\_al1 het type van expr\_al2
\item als exp\_1 != expr\_al2 dan is het type van expr\_al1 een boolean
\end{itemize}
\subsubsection{Semantiek}
De eerste expr\_al2 zal op de stack worden gezet. Hierna wordt er telkens een expr\_al2 erbij gezet. De OR-operatie zal worden aangeroepen en het resultaat blijft op de stack zijn. Als er nog een expr\_al2 is dan zal deze ook op de stack worden gezet en wordt de OR-operatie opnieuw aangeroepen. Aldoende blijft er uiteindelijk 1 waarde op de stack staan.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
true OR false;
true OR false OR foo;
\end{lstlisting}

\subsection{Expressies - AND}
Hier wordt de AND-expressie beschreven. Net zoals bij de OR-expressie is het mogelijk nul tot veel AND-operatoren achter elkaar te plakken. De AND-expressie is een niveau hoger dan de OR-expressie en zal dus eerder worden uitgevoerd. \\
Het is eventueel mogelijk later in de compiler om een AND eerder af te breken aangezien als er een false in het rijtje zit het resultaat altijd false is. Wij hebben deze optimalisatie er nog niet inzitten, dit omdat sommige expressies ongeacht de eerdere expressies uitgevoerd dienen te worden, denk bijvoorbeeld aan een READ()-statement dat anders niet uitgevoerd zou worden.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={167-169}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Als expr\_al2 enkel uit 1 expr\_al3 bestaat dan zijn er geen restricties
\item In de andere gevallen dienen alle expr\_al3 van het type boolean te zijn.
\item als exp\_2 == expr\_al3 dan is het type van expr\_al2 het type van expr\_al3
\item als exp\_2 != expr\_al3 dan is het type van expr\_al2 een boolean
\end{itemize}
\subsubsection{Semantiek}
Hetzelfde als bij het OR-statement. De waardes zullen op de stack geladen worden en er zal telkens een AND-operatie op 2 waardes worden uitgevoerd. De resulterende waarde is weer geschikt voor bijvoorbeeld nog een AND-operatie.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
foo AND bar;
foo AND false AND bar;
\end{lstlisting}

\subsection{Expressies - Relaties}
Hier worden bijna alle comperatoren afgehandeld. Het is belangrijk dat er in de checker goed wordt gekeken of de types van de linker en rechterzijde compatible zijn.
\subsubsection{Syntax}
%		: expr_al4 ((RELS|RELSE|RELG|RELGE|RELE|RELNE)^ expr_al4)*
\lstinputlisting[style=ANTLR,linerange={171-173}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item alle expr\_al4 dienen van hetzelfde type te zijn
\item bij een operatie tussen twee expr\_al4 anders dan RELE \& RELNE dient expr\_al4 een integer te zijn.
\item als exp\_3 == expr\_al4 dan is het type van expr\_al3 het type van expr\_al4
\item als exp\_3 != expr\_al4 dan is het type van expr\_al3 een boolean
\end{itemize}
\subsubsection{Semantiek}
Vergelijkbaar met andere binaire operatoren zoals AND en OR, er zullen waardes op de stack worden gezet en de operatie zal 1 waarde achterlaten op de stack.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
5 > 6;
true == false;
5 == 42;
\end{lstlisting}

\subsection{Expressies - plus en minus}
Hier zijn we aangeland bij de eerder genoemde 6+3*12, plus en minus zit 1 niveau lager dan de vermenigvuldigingen.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={175-177}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item als er minimaal 1 operatie wordt uitgevoerd dan dient expr\_al5 een integer te zijn
\item als exp\_4 == expr\_al5 dan is het type van expr\_al4 het type van expr\_al5
\item als exp\_4 != expr\_al5 dan is het type van expr\_al4 een integer
\end{itemize}
\subsubsection{Semantiek}
Wederom een binaire operatie. Let op, de unaire plus en minus komen nog. Dus 5--6 zal de tweede minus niet hier worde opgevangen.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo := 5;
foo := 5 + 37;
10 + 50 - 18;
\end{lstlisting}

\subsection{Expressies - delen en vermenigvuldigen}
Naast delen en vermenigvuldigen is het ook mogelijk een modulus te nemen.
Wat wellicht is opgevallen bij het bovenstaande, is dat het mogelijk is om enkel een som in de code te zetten. Dit vinden wij prima, echter moet daarbij wel de resulterende waarde gepopped worden als die niet meer gebruikt wordt.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={179-181}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item als er minimaal 1 operatie wordt uitgevoerd dan dient expr\_al6 een integer te zijn
\item als exp\_5 == expr\_al6 dan is het type van expr\_al5 het type van expr\_al6
\item als exp\_5 != expr\_al6 dan is het type van expr\_al5 een integer
\end{itemize}
\subsubsection{Semantiek}
Hetzelfde als bij optellen. Goed om te weten is dat de geretouneerde waarde een integer is, dus er zal worden afgerond.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo := 6;
foo := 6*7;
foo := 21*6%84;
\end{lstlisting}


\subsection{Expressies - unaries}
Hier wordt gekeken of de expressie eventueel een NOT-, PLUS- of MIN-operator voor zich heeft staan.
Om later verwarring te voorkomen zullen PLUS en MIN vervangen worden door speciale terminals, zijnde UMIN en UPLUS. UPLUS zou eventueel weg kunnen worden gelaten aangezien +x==x.
Als er geen operator voor de expressie staat dan is expr\_al6 gewoon een expr\_al7
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={183-191}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_al7 dient bij PLUS expr\_al7 een integer te zijn
\item expr\_al7 dient bij MIN expr\_al7 een integer te zijn
\item expr\_al7 dient bij NOT expr\_al7 een boolean te zijn
\item het type van expr\_al6 het type van expr\_al7
\end{itemize}
\subsubsection{Semantiek}
Bij UMIN zal expr\_al6 == - expr\_al7 \\
Bij UPLUS zal expr\_al6 == expr\_al7 \\
Bij NOT zal expr\_al6 == ! expr\_al7 
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
one := +1;
evil := -42;
foo := not foobar;
\end{lstlisting}

\subsection{Expressies - toplevel}
Op het hoogste nivau kan een expressie bestaan uit een semi-statement zoals een if-expressie of een print-expressie, of het kan een identifier of waarde zijn, of het kan een aparte (compound)expressie binnen haken zijn.
Zoals je ziet stond in eerste de assignment hier. Maar aangezien het meest linkerdeel van een assignment een identiefier is kan op L=1 geen onderscheid worden gemaakt tussen identifier of een assignment. Vandaar dat een assignment bij expr\_al1 is gedefineerd.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={193-204}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_al7 is van hetzelfde type als de gegeven expressie of waarde.
\end{itemize}
\subsubsection{Semantiek}
Dit is enkel een lijst van mogelijke expressies en waardes en dus zal er in de compiler enkel deze expressie of waarde op stack hebben staan, maar wordt er geen operatie op uitgevoerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo;
42;
(foobar);
\end{lstlisting}

\subsection{Unsigned constants}
Uiteraard bied onze taal ook de mogelijkheid aan om constanten te gebruiken zonder deze eerst te moeten declareren. Oftewel, je kunt gewoon nummers gebruiken bijvoorbeeld.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={244-260,266-268}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item unsignedconstant is van het type van de gegeven waarde
\item boolval is een boolean type
\item charval is een char
\item intval is een integer
\end{itemize}
\subsubsection{Semantiek}
De desbetreffende waarde wordt op de stack gezet.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
'Y';
42;
true;
\end{lstlisting}

\subsection{Identifier}
Een identifier van een bestaande variabele of constante in de huidige of een hogere scope.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={261-264,275-277}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De identifier dient te verwijzen naar een geldige variabele of constante
\item Het type is het type van de variabele of declaratie waar de identifier naar verwijst.
\end{itemize}
\subsubsection{Semantiek}
Er zal een commando aangeroepen worden om de waarde uit het geheugen te laden. Deze waarde wordt dan op de stack gezet. Bij constanten gebeurd dit ook. Eventueel zou je ook de constante zelf al kunnen neerzetten op de stack, dit scheelt weer wat werk voor de processor. Dit doen wij echter niet momenteel.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
Answer42;
\end{lstlisting}

\subsection{Read}
Om contact te hebben met de buitenwereld kan onze taal lezen en schrijven naar de standard-out. 
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={205-207}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Identifier dient te verwijzen naar een geldige identifier
\item De ingelezen waarde dient van het zelfde type als identifier te zijn
\item Als er 1 identifier is opgegeven dan geeft read de gelezen waarde/type terug
\item Als er meer dan 1 identifier wordt ingelezen dan is het returntype void
\end{itemize}
\subsubsection{Semantiek}
Het read-commando wordt aangeroepen en de waarde wordt van de standard-out gelezen en op de stack gezet. Vervolgens wordt die waarde opgeslagen in de variabele.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
read(foo);
read(foo,bar);
\end{lstlisting}

\subsection{Print}
De taal heeft ook de mogelijkheid om dat wat er bijvoorbeeld berekend is naar buiten te communiceren.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={209-202}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item -
\end{itemize}
\subsubsection{Semantiek}
De waarde van de expressie staat op de stack. Vervolgens wordt deze netjes naar het scherm uitgevoerd. Afhankelijk van het type zal dat anders gebeuren. 
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
print(42);
print('4','2');
\end{lstlisting}

\subsection{If}
Om keuzes in het programma mogelijk te maken zal er een conditioneel statement nodig zijn, het IF-statement is een dergelijk statement. Een ELSE-deel is optioneel.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={213-215}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De eerste compoundexpression moet een boolean-type retouneren
\item De if retouneerd een type void
\todo{retourtype}
\end{itemize}
\subsubsection{Semantiek}
Als de waarde binnen het ifstatement waar is dan zal de eerste compoundexpressie worden uitgevoerd (na de then). Anders zal de andere compoundexpressie worden uitgevoerd, mits deze is gedeclareerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
if true; then i := 42; fi
if false; then i := 0; else i:=42; fi
\end{lstlisting}

\subsection{While}
De while zal net zolang een blok code uitvoeren tot een gegeven expressie waar is.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={217-219}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De eerste compoundexpression moet een boolean-type retouneren
\item De while retouneerd een type void
\end{itemize}
\subsubsection{Semantiek}
De tweede compoundexpression zal worden uitgevoerd tot de eerste compoundexpression waar is. Het kan zijn dat de tweede compoundexpression nooit wordt uitgevoerd dus.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
while false; do 
\\ this is not gonna be executed
tru := false;
od

while foo<5; do
foo := foo + 1;
od
\end{lstlisting}

\subsection{Functieaanroep}
Een functieaanroep naar een eerder gedefineerde functie
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={221-223}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Het aantal expressies en hun type dient overeen te komen met de declaratie van de functie
\item De functie retouneert het eerder gespecificeerde type. Als er geen type was gedeclareerd dan is dat dus void.
\end{itemize}
\subsubsection{Semantiek}
Het returnadres wordt op de stack gezet, zodat de functie weer hiernaartoe kan terugkeren.
De expressies worden op de stack gezet in de gespecificeerde volgorde.
De functie wordt aangeroepen.
De functie returned en het result staat op de stack.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo();
i := foo('b','a','r',);
\end{lstlisting}


\subsection{Closed expression}
Een expressie tussen haakjes is soms handig, bijvoorbeeld bij sommetjes: (5+2)*6;
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={229-231}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De geretouneerde waarde zal de waarde van de expressie zijn binnen de haakjes.
\item Het retourneerde type is ook hetzelfde als die van de expressie.
\end{itemize}
\subsubsection{Semantiek}
De expressie binnen de haakjes zal worden uitgevoerd binnen de haakjes.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
(3*(6+8))%102;
\end{lstlisting}

\subsection{Closed compoundexpression}
Is een compoundexpressie binnen haakjes. Verschil met de expressie tussen haakjes is dat deze ook toestaat om declaraties te gebruiken. Een compound tussen haakjes zal een eigen scope hebben.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={225-227}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item retouneerd het waarde en de type van de laatste expressie in de compound, dit kan van het type void zijn.
\end{itemize}
\subsubsection{Semantiek}
De compoundexpressie zal in een eigen scope worden uitgevoerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
{
var foo: integer;
foo := 40;
foo+2;
}
\end{lstlisting}


\todo{expression\_statement}

%
%expression_statement
%	: expression SEMICOLON
%		-> ^(EXPRESSION_STATEMENT expression)
%	;
%


%==================================OPMAAK======================================

%\subsection{Expressies - }
%
%\subsubsection{Syntax}
%\lstinputlisting[style=ANTLR,linerange={131-137}]{../g-files/SELMA.g}
%\subsubsection{Context}
%\begin{itemize}
%\item
%\end{itemize}
%\subsubsection{Semantiek}
%
%\subsubsection{Voorbeeld}
%\begin{lstlisting}[style=SELMA]
%\end{lstlisting}

%==================================OPMAAK======================================

\newpage
\section{Vertaalregels}
Deze sectie specificeerd hoe selma programmas naar Jasmin worden vertaald. Jasmin is een assembler die gegeven Jasmin assembly JVM bytecode genereerd in de vorm van een \texttt{.class} file.

De vertaling wordt gedaan door middel van een compiler (g-files/SELMACompiler.g) in ANTLR die executeerd na de checker en producties uit de Jasmin string template aanroept (SELMACodeJasmin.stg).

We gebruiken de volgende code functies:

\begin{itemize}
	\item run       : Program     -> Instruction*
	\item execute   | ExpressionStatement -> Instruction*
 	\item evaluate  : Expression  -> Instruction*
 	\item fetch		  : Identifier  -> Instruction*
 	\item assign    : Identifier   -> Instruction*
 	\item elaborate : VarDeclaration -> Instruction*
\end{itemize}

\begin{tabular}{| l | c | l |}
	Phare   & Code Function & Effect \\ 
	\hline \hline
  Program & run P       & Run P en begin en eindig met een lege stack. Doe ook de \\
  &&                      nodige declaraties om classen en methoden te genereren. \\
  &&											 Return hierna.\\ 
  \hline
  ExprStat & execute E  & Executeer statement S. Als S een expressie is dat \\
  && 										 een waarde op de stack genereerd, pop. Dit veranderd de \\
  &&											 stack niet. \\ 
  \hline
  Expression & evaluate E & Evalueer expressie E en laat de nieuwe waarde op de stack staan.\\
  &&												 Een expressie kan 1 of 2 oude waarden van de stack halen (e.g. AND). \\ 
  \hline
  ID				   & fetch I    & Laad de waarde van I en zet het op de stack. \\
  \hline
  ID					 & assign I   & Pop de top van de stack en sla het op in I. \\
  \hline
\end{tabular}

In onze vertaalregels zullen we variabelen omringen met \textless en \textgreater.

\subsection{Run}
\subsubsection{Program}
\begin{verbatim}
run[P, source_file, stack_limit, locals_limit, pop] = 
	  .source <source_file>
	  .class public Main
	  .super java/lang/Object
	  .field public static scanner_field Ljava/Util/Scanner;
	  
	  .method public static main([Ljava/lang/String;)V
	  .limit stack <stack_limit>
	  .limit locals <locals_limit>
    new java/util/Scanner
    dup
    getstatic java/lang/System/in Ljava/io/InputStream;
    invokespecial java/util/Scanner/<init>(Ljava/io/InputStream;)V
    putstatic Main/scanner_field Ljava/util/Scanner;

    evaluate[P]
    if <pop>:
        pop

    return
.end method
\end{verbatim}

De \texttt{source\_file}, \texttt{stack\_limit} en \texttt{locals\_limit} geven respectievelijk aan wat de originele source file was (voor runtime excepties), de grootte van de stack en het aantal locale variabelen dat het programma gebruikt. \texttt{pop} geeft aan of P een expressie was en nog een waarde op de stack heeft achtergelaten. Dit zou ook opgelost kunnen worden door de regel

\begin{verbatim}
    program -> expression_statement
    expression_statement -> expression
    expression -> ... | compoundexpression
    compoundexpression -> (declaration | expression_statement)* 
\end{verbatim}

in plaats van

\begin{verbatim}
    program -> compoundexpression
\end{verbatim}

Helaas resulteerd dit in Left Recursion waar we geen tijd meer voor hadden dit op te lossen. Een simpele \texttt{pop = expression.type != type.VOID} lost dit echter gauw genoeg op.\\
\\
Als er labels in code regels voorkomen als L1, L2, etc, zullen deze in werkelijkheid uniek genummerd zijn.

\subsection{Execute}
\subsubsection{ExpressionStatement}

\begin{verbatim}
execute[S, pop] =
    evaluate[S]
    if pop:
        pop
\end{verbatim}

\texttt{S} is hierbij een expressie en pop is wederom true iff \texttt{expression.type != type.VOID}.

\subsubsection{while}
\begin{verbatim}
execute[while E; do S; od] =
    L1:
        evaluate[E]
        ifeq	 L2	
        execute[S]
        goto L1
    L2:
\end{verbatim}

De \texttt{ifeq} instructie kijkt of de waarde op de top van de stack gelijk is aan 0 (boolean waarden zijn integer waarden 0 of 1), en als dat het geval is jumpt de interpreter naar de label L2 (naar de eerstvolgende instructie na de while loop). Als dit niet het geval is gaat hij verder met de eerste instructie van \texttt{S} en hierna volgt een jump naar het begin om te kijken of een volgende iteratie nodig is.

\subsection{Evaluate}
\subsubsection{Compound Expression}
Omdat een compound expression ook weer een expressie is, maar bestaat uit expressie statements, moet de codegenerator de mogelijk gegenereerde pop van de laatste expressie statement verwijderen. De regel is als volgt:

\begin{verbatim}
compoundexpression = COMPOUND (declaration | expression_statement)*

evaluate[E, last_expr_is_void] =
    evaluate[E]
    if not <last_expr_is_void>:
    	    remove_last_instruction
\end{verbatim}

Hier geeft de variabele \texttt{last\_expr\_is\_void} aan of de laatste expressie (als er tenminste 1 expressie is) van type VOID is. Als dit niet het geval is, is er een pop gegenereerd door \texttt{expression\_statement} die verwijderd moet worden. Dit gebeurt door een dummy instructie \texttt{remove\_last\_instruction} te genereren die de laaste instructie verwijderd. Dit gebeurd voordat het resultaat naar een Jasmin aseembly file geschreven wordt.

\subsubsection{if then else expression}

\begin{verbatim}
evaluate[if E1 then E2 (else E3)?] =
        evaluate[E1]
        ifeq L1
        evaluate[E2]
        goto L2
    L1:
        evaluate[E3]
    L2:
\end{verbatim}

\subsubsection{Identifier}
\label{Identifier}

\begin{verbatim}
evaluate[ID, kind] =
    if kind == CONST:
        ldc getvalue(<ID>)
    else:
        iload address_of(<ID>)
\end{verbatim}

Als de variabele een constante is wordt de waarde bijgehouden in de symbol table. De functie \texttt{getvalue} haalt hier de waarde van de constante op.
\texttt{address\_of} is hier een functie die gegeven een identifier zijn address als locale variabele ophaalt.

\subsubsection{Integer Literal}
\begin{verbatim}
evaluate[literal, iconst, bipush, ldc] =
    if iconst:	
        iconst_<literal>
    elif bipush:
        bipush <literal>
    else:	
        ldc <literal>
\end{verbatim}

Als de integer literal in de juiste range van iconst of bipush zit, worden deze geprefereerd over ldc voor compactere bytecode.

\subsubsection{Character Literal}
\begin{verbatim}
evaluate[literal] =
    bipush <literal>
\end{verbatim}

\subsubsection{Boolean Literals}
\begin{verbatim}
evaluate[true] =
    iconst_1
\end{verbatim}

en

\begin{verbatim}
evaluate[false] =
    iconst_0
\end{verbatim}

\subsubsection{Arithmetic, AND en OR}
\begin{verbatim}
evaluate[E1, op, E2, instruction] =
    evaluate[E1]
    evaluate[E2]
    <instruction>		; E1 <op> E2
\end{verbatim}

Hierbij is op een binaire arithmetic operator zoals \texttt{+}, \texttt{-}, etc, of AND/OR. \texttt{instruction} is de bijbehorende JVM Jasmin instructie. De operators mappen als volgt naar hun instructies:

\begin{itemize}
	\item \texttt{+} : \texttt{iadd}
	\item \texttt{-} : \texttt{isub}
	\item \texttt{*} : \texttt{imul}
	\item \texttt{/} : \texttt{idiv}
	\item \texttt{\%} : \texttt{irem}
	
	\item \texttt{\&\&} : \texttt{iand}
	\item || : \texttt{ior}
\end{itemize}

\subsubsection{Relational operators}

\begin{verbatim}
evaluate[E1 op E2, instruction] =
    evaluate[E1]
    evaluate[E2]
    <instruction> L1	  ; E1 <op> E2
    iconst_0
    goto L2
L1:
    iconst_1
L2:
\end{verbatim}

Voor elke relational relational operator zoals \texttt{\textless=}, \texttt{==} etc wordt deze code gegenereerd met bijbehorende instructie. De opererator naar instructie mapping is als volgt:

\begin{verbatim}
	<  : ifcmp_lt
	<= : ifcmp_le
	== : ifcmp_eq
	!= : ifcmp_ne
	>= : ifcmp_ge
	>  : ifcmp_gt
\end{verbatim}

\subsubsection{Unary Plus and Minus}
\begin{verbatim}
evaluate[-E] =
    evaluate[E]
    ineg	
\end{verbatim}

Voor unary \texttt{+} hoeft er niets te gebeuren.

\subsubsection{NOT}
\begin{verbatim}
evaluate[!E] =
    evaluate[E]
    ifeq L1
    iconst_0
    goto L2
L1:
    iconst_1
L2:
\end{verbatim}

\subsubsection{Assignment}
\begin{verbatim}
evaluate[ID := E, address] =
    evaluate[E]
    dup
    istore <address>
\end{verbatim}

\texttt{address} is het address van de locale variabele. De \texttt{dup} is nodig om de waarde eerst te dupliceren aangezien assignment een expressie is.

\subsubsection{Print}
\begin{verbatim}
evaluate[print(E+), type_denoters, bools, dup_top] =
    for expr, type_denoter, is_bool in E, type_denoters, bools:
        evaluate[expr]

        if <dup_top>:
            dup		
		
        if <is_bool>:
                ifeq L1
                ldc "true"
                goto L2
            L1:
                ldc "false"
            L2:
		
        getstatic java/lang/System/out Ljava/io/PrintStream;
        swap
        invokevirtual java/io/PrintStream/println(<type_denoter>)V
\end{verbatim}

Hier krijgt de vertaalregel voor elke expressie mee of het type \texttt{boolean} is (\texttt{bools}), en welke overloaded versie van \texttt{System.out.println} moet worden aangeroepen (\texttt{type\_denoters}). In het geval van een boolean moet de waarde \texttt{"true"} of \texttt{"false"} worden geladen in plaats van de integer waarde. De boolean dup\_top geeft aan of de print een statement of expressie is. Als het een expressie is (in het geval van een enkele print), moet de waarde worden gedupliceerd op de stack voordat de println de waarde popt.

\subsubsection{Read}
\begin{verbatim}
evaluate[read(ID+), bools, ints, dup_top] =
    for id, is_bool, is_int in ID, bools, ints:
		    getstatic Main/scanner_field Ljava/util/Scanner;
		
        if <is_bool>:
            invokevirtual java/util/Scanner/nextBoolean()Z
        elif <is_int>:
            invokevirtual java/util/Scanner/nextInt()I
        else:
            invokevirtual java/util/Scanner/nextByte()I		
				
        if <dup_top>:
            dup		
		
        istore address_of(<id>)
\end{verbatim}

Hier krijgt de vertaalregel voor elke expressie mee of het type \texttt{boolean} of int is (\texttt{bools}, texttt{ints}) en of de read een expressie is (\texttt{dup\_top}). \texttt{address\_of} is hier een functie die gegeven een identifier zijn address als locale variabele ophaalt. Afhankelijk van het type (boolean, integer of character) wordt een aanroep gedaan naar de methoden nextBoolean(), nextInt() of nextByte() van Scanner.

\subsection{Elaborate}
De elaborate code functie genereerd geen code, maar maakt entries aan in de compiler's symbol table.

\begin{verbatim}
elaborate[VarDeclaration type ID] =
    increase amount of local variables by one
    enter <ID> of <type> in symbol table

elaborate[ConstDeclaration type ID value] =
    increase amount of local variables by one
    enter <ID> of <type> in symbol table
    set value on symbol table entry of <ID>
\end{verbatim}

Constanten nemen geen ruimte in op de stack of als locale variabelen maar worden in de symbol table bijgehouden. Variabelen zijn locale variabelen in de JVM. Dit betekent dat variabelen in de global scope niet beschikbaar zijn voor functies, aangezien dat andere methoden zijn en geen closures over de main functie. Hiervoor zouden het statische of non-statische fields moeten zijn. Zie ook de subsectie over Identifiers \ref{Identifier}.

\newpage
\section{Beschrijving van Java programmatuur}
%Beknopte bespreking van de extra Java klassen die
%u gedefinieerd heeft voor uw compiler (b.v. symbol table management, type checking, code
%generatie, error handling, etc.). Geef ook aan welke informatie in de AST-nodes opgeslagen
%wordt.
%
%
%CheckerEntry.java    SELMA.java
%CompilerEntry.java   SELMATreeAdaptor.java
%IdEntry.java         SELMATree.java
%SELMAException.java  SymbolTable.java
\subsection{main - SELMA}
SELMA.java is het main-programma. Je kunt een aantal opties en een SELMA-sourcecodefile meegeven.
Hierna zal SELMA desbetreffende file parsen en compileren. De opties die mogelijk zijn zijn:
\begin{itemize}
\item -ast Er zal een ast-diagram naar de stdOut worden geprint van de source-code.
\item -dot Er zal een dot-diagram naar de stdOut worden geprint van de source-code.
\item -no\_checker De source-code wordt geparsed maar niet gechecked.
\item -code\_generator De source-code zal worden gecompiled
\end{itemize}
De sourcecode zal de volgende stappen doorlopen: \\
\begin{tabbing}
\hspace{5em}\=\hspace{5em}\=\hspace{7em}\=\hspace{5em}\=\hspace{10em}\=\kill
Lexer \>  Parser \> -no\_checker 	\>   		\> -ast \>  Ast-diagram \\
Lexer \>  Parser \> -no\_checker 	\>   		\> -dot \>  Dot-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -ast \>  Ast-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -dot \>  Dot-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -code\_generator \>  Code 
\end{tabbing} 
Alle resultaten zullen altijd naar de stdOut worden geprint.

\subsection{SELMAException}
Als er wat fout gaat in bijvoorbeeld de checker dan zal er een exception worden gegooid. Deze exception is een SELMAException. Aan de exception wordt de node meegegeven waar de checker op dat moment mee bezig is. En de toString()-functie van SELMAException zal dat dan ook mooi formatten in de vorm van "(regelnummer:columnnummer) Errormessage", toch wel fijn als je moet debuggen. 

\subsection{SELMATreeAdaptor}
Deze TreeAdaptor heeft SELMATree als nodes, in plaats van een normale Tree.

\subsection{SELMATree}
SELMATree is een uitbreiding op de normale tree. En kan een aantal extra dingen bijhouden, namelijk of een expressie constant is of variabel, wat later handig is voor optimizing. En wat het type is van de expressie, dat is zeer handig voor de checker.
Daarvoor heeft SELMATree een paar extra attributen, zijnde:
\lstinputlisting[style=JAVA,linerange={26-30}]{../src/SELMA/SELMATree.java}
En verder kent SELMATree nog drie functies om mooi te kunnen printen:
\lstinputlisting[style=JAVA,linerange={32-32,36-36,68-68}]{../src/SELMA/SELMATree.java}

\subsection{SymbolTable}
De symboltable houdt al onze variabelen en constanten bij. Ook kun je in de symboltable scopes aanmaken, om bijvoorbeeld variabelen binnen een compoundexpressie te kunnen declareren. De dataopslag van de symboltable geschiedt middels een Map waarin een string aan een stack van IDEntries wordt gekoppeld. De string verwijst naar de naam van de variabele of constante. De stack bevat meerdere declaraties van die variabele met die naam in verschillende scopes. Zodat het mogelijk is de zelfde naam tweemaal te gebruiken, mits ze in een andere scope gebruikt worden.\\
\\
De symboltable kent een aantal functies, de belangrijkste zijn:
\lstinputlisting[style=JAVA,linerange={28-32,36-42,58-66,88-94}]{../src/SELMA/SymbolTable.java}

\subsubsection{SymbolTableException}
SymbolTableException is er om fouten in de symboltable aan te geven. Deze fouten zullen vergelijkbaar worden geformat als die van SELMAException, namelijk "(line:column) ErrorMsg.

\subsection{IDEntry}
De symboltable bevat voor elke variabele of constante een IDEntry. Een IDEntry bevat de scopelevel van desbetreffende declaratie. Wij gebruiken in onze code echter een tweetal klasses die ge-extend zijn op IDEntry; CheckerEntry en CompilerEntry.

\subsection{CheckerEntry}
De CheckerEntry wordt gebruikt in de Checker. Een checkerEntry verschilt van een IDEntry op het punt dat een checkerEntry twee extra waardes heeft om bij te houden wat het type is van de variabele of constante (int,bool of char). De tweede waarde is om bij te houden of we met een constante of een variabele te maken hebben.
\lstinputlisting[style=JAVA,linerange={7-8}]{../src/SELMA/CheckerEntry.java}

\subsection{CompilerEntry}
De compilerEntry is weer een uitbreiding op de CheckerEntry. Voor de compiler is het namelijk noodzakelijk om te weten op welk adres in de te genereren code de variabele staat. Dit wordt bijgehouden door:
\lstinputlisting[style=JAVA,linerange={7-7}]{../src/SELMA/CompilerEntry.java}

\newpage
\section{Testplan en -resultaten}
Voor het testen hebben we testprogramma's geschreven in onze taal. Ook zit er een testrunner bij die automatisch alle tests in de 'test' subdirectory vind en compileerd en optioneel executeerd.
Tests kunnen van de volgende typen zijn:
\begin{itemize}
	\item Compile - Compileer de test
	\item Error	    - Compileer en (als successvol), executeer
	\item Run		    - Compileer en executeer
\end{itemize}

Bij deze tests kunnen in het programma tags gezet worden, namelijk <input>text</input> voor input voor het programma op stdin, en <output>text</output> voor output van het programma (of de compiler, in het geval van een compile of error test). Error tests beginnen met de prefix 'error\_' in de bestandsnaam, en compile tests met 'compile\_'. Zo kan getest worden voor juiste syntax en semantiek, juiste error reporting bij onjuiste syntax en semantiek, en correctie vertaalregels door middel van correcte executie, en runtime error checking voor juiste programmas met runtime fouten. Om de tests te runnen is Python 2.5+ < 3.0 nodig. De tests kunnen als volgt worden geexecuteerd:

\begin{lstlisting}
\$ python test.py
\end{lstlisting}

of

\begin{lstlisting}
\$ make tests
\end{lstlisting}


Als een run test geen output heeft gespecificeerd is de exit status van het programma bepalend of de test faalt of niet. Bij een error test geldt het tegenovergestelde: zonder gespecificeerde output moet de exit status nonzero zijn.

De tests in de test directory testen alle constructen uit de taal, zoals arithmetic, alle operators, typen, constanten, scope rules, etcetera. Hieronder is output gegeven van de test runner. Als een test faalt zal de output worden weergegeven:

\begin{lstlisting}[style=SELMA]
[0] [11:11] ~/selma git(master!) âž¤ python test.py
Run        test/correct.selma                                 ...  OK
Error      test/error_context.selma                           ...  OK
Error      test/error_if.selma                                ...  OK
Error      test/error_runtime_uninitialized.selma             ...  OK
Error      test/error_runtime_zerodivision.selma              ...  OK
Error      test/error_syntax.selma                            ...  OK
Error      test/error_while.selma                             ...  OK
Error      test/error_while_void.selma                        ...  OK
Run        test/sample.selma                                  ...  FAIL (exit status 0)
  Got:
        h
    >>> a
        l
        l
        o
  Expected:
        h
    >>> e
        l
        l
        o
--------------------------------------------------------------------------------
Run        test/test_if.selma                                 ...  OK
Run        test/test_operators.selma                          ...  OK
Run        test/test_while.selma                              ...  OK
Run        test/test_functions/correct_functions.SELMA        ...  FAIL (exit status 1)
        ERROR: recognition exception thrown by compiler: null
        org.antlr.runtime.EarlyExitException
        at SELMA.SELMACompiler.compoundexpression(SELMACompiler.java:271)
        at SELMA.SELMACompiler.program(SELMACompiler.java:170)
        at SELMA.SELMA.main(SELMA.java:99)
--------------------------------------------------------------------------------
Error      test/test_functions/error_doublefunction.selma     ...  OK
Error      test/test_functions/error_wrongparamcount.selma    ...  OK
Error      test/test_functions/error_wrongparamtype.selma     ...  OK
Error      test/test_functions/error_wrongreturntype.selma    ...  OK
Ran 17 test(s), SUCCESS=15, FAILURE=2
\end{lstlisting}

Hier zien we dat \texttt{test/sample.selma} niet de correcte output heeft, maar wel executeerde zonder fouten (exit status 0), terwijl \texttt{test/test\_functions/correct\_functions.SELMA} een compilatie fout had met een exit status 1. De eerste colom geeft het type test aan, in dit geval 'Error' of 'Run'. Ter demonstratie is \texttt{test/sample.selma} bijgevoegd:


\begin{lstlisting}[style=SELMA]
<output>
    h
    e
    l
    l
    o
</output>
print('h', 'a', 'l', 'l', 'o');
\end{lstlisting}

\newpage
\section{Conclusies}



\newpage
\section{Appendix}

\subsection{ANTLR Lexer \& Parser specificatie}
%Specificatie van de invoer voor de ANTLR scanner generator,
%d.w.z. de token-definities van het taaltje.

%Specificatie van de invoer voor de parser generator, d.w.z. de
%structuur van de taal en de wijze waarop de AST gegenereerd wordt
\lstinputlisting[style=ANTLRfile]{../g-files/SELMA.g}

\newpage
\subsection{ANTLR Checker specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMAChecker.g}

\newpage
\subsection{ANTLR Codegenerator specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMACompiler.g}

\begin{landscape}
\newpage
\subsection{ANTLR Codegenerator Stringtemplate specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMACodeJasmin.stg}
\end{landscape}

\newpage
\subsection{Invoer- en uitvoer van een uitgebreid testprogramma}
Van een correct en uitgebreid test-
programma (met daarin alle features van uw programmeertaal) moet worden bijgevoegd: de
listing van het oorspronkelijk programma, de listing van de gegenereerde TAM-code (be-
standsnaam met extensie .tam) en een of meer executie voorbeelden met in- en uitvoer
waaruit de juiste werking van de gegenereerde code blijkt.


\end{document}