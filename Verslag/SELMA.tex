\documentclass[]{article}

\title{SELMA}
\author{ 
Vonk, J\\
s0132778\\
Matenweg 75-201\\
\\
Florisson, M\\
s000000\\
Box Calslaan xx-30}

\usepackage{listings}
\usepackage{lscape}
\usepackage{color}
\usepackage[pdftex,bookmarks=true]{hyperref}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\begin{document}

\lstdefinestyle{ANTLR}
	{frame=shadowbox, breaklines=true,basicstyle=\footnotesize}
\lstdefinestyle{SELMA}
	{frame=shadowbox, breaklines=true,basicstyle=\small}
\lstdefinestyle{JAVA}
	{frame=shadowbox, language=Java, breaklines=true,basicstyle=\footnotesize}
\lstdefinestyle{ANTLRfile}
	{frame=LB, breaklines=true, basicstyle=\scriptsize, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	
\lstdefinestyle{SELMAfile}
	{frame=LB, breaklines=true, basicstyle=\scriptsize, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	
\lstdefinestyle{JAVAfile}
	{frame=LB, language=Java, breaklines=true, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	
\lstdefinestyle{JVMfile}
	{frame=LB, breaklines=true, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}	

\newcommand{\todo}[1]{\marginpar{\fcolorbox{red}{yellow}{\textbf{#1}}}}



\begin{titlepage}
\maketitle 
\end{titlepage}
\tableofcontents{}

\newpage
\section{Inleiding}
%Korte beschrijving van de practicumopdracht.
Voor vertalerbouw dient als eindopdracht een eigen taal geschreven te worden. Deze taal dient een expression-language te zijn, dit is een taal die geen statements, maar enkel expressies kent. Alles wat je dus aanroept zal een waarde teruggeven.\\
Voor deze zelfbedachte taal dient een parser en lexer geschreven te worden, een checker en een compiler. Hierbij dient een verslag met een uitgebreide beschrijving van de taal en een goede kijk op hoe alles onder de motorkap werkt. Ook moet er een bewijs worden geleverd dat de taal werkt, dit kan door een testprogramma te schrijven dat tamelijk uitgebreid is en te kijken of dit werkt naar behoren. (exhaustive testing) \\
Hoe uitgebreid de te definieren taal wordt is aan de studenten zelf - dit is echter terug te zien in het te behalen cijfer.\\
Voor onze taal, SELMA, hebben wij gekozen voor het volgende:
\todo{Klopt?}
\begin{itemize}
\item Basic Expression Language
\item If- \& while-statements
\item Ondersteunen van functies
\item Compileren naar JVM-code in plaats van TAM-code
\end{itemize}

Onze taal heet SELMA. Een naam aan een taal geven is lastig, zo waren er een aantal andere opties zoals: SMEF of Taal voor Vertalerbouw (TV).
SELMA staat voor Simpel Expression Language. Nu moest de afkorting wat meer zeggen dus kozen we voor de meisjesnaam SELMA, alleen maar omdat een afkorting vinden voor SELDERIE wel heel veel werk is.\\
Gelukkig heet onze taal dus geen SELDERIE, maar SELMA:\\
Waarbij de MA voor Minor Adjustments stond, we hebben inmiddels zoveel werk eraan gehad dat "Minor" dat geen eer meer aan doet. \\
Dus met gepaste trots presenteren wij u SELMA:\\
Simple Expression Language Met Augurk\\
Vanaf nu enkel nog naar te verwijzen als SELMA.\\

\newpage
\section{Beknopte beschrijving}
%van de programmeertaal (maximaal een A4-tje).
Onze taal is gemaakt naar de gegeven instructies van de practicumhandleiding en alles is of een expressie of declaration in deze taal. Bij sommige expressies is het echter niet mogelijk een resultaat te geven, hier kunnen die expressies niet anders dan een void-resultaat retouneren, wat ze effectief een statement maakt. De structuur van de taal en de keywords lijken qua layout op een hybride tussen C en Pascal. \\
De volledige taal is LL(1) wij hebben hierdoor vooral tijdens het ontwerpen goed moeten nadenken hoe we de taal zo logisch mogelijk opbouwden zodat de parser er mee uit de voeten kon. Eventueel is er de mogelijkheid om lokaal 1 stap verder te kijken, wij hebben dit echter niet nodig gehad omdat wij voldoende keywords hebben gebruikt, zoals voor een functie een @ zetten - en we in de parser bewust rekening hebben gehouden met de LL(1) limitatie.\\
\todo{@?}
\\
SELMA compileerde in eerste instantie naar TAM, op de cd is een fragment van deze code te zien. We hebben echter besloten dat het mooier was om JVM te gebruiken, niet zo zeer uit praktisch oogpunt, maar meer omdat JVM-bytecode ook door "echte" talen wordt gebruikt en omdat het een pluspunt is in de eindbeoordeling.\\
Op het moment dat we besloten om te schakelen waren we blij dat we haddne gekozen voor het gebruik van stringTemplates bij de codegeneratie, dit heeft ons wat werk gescheeld. En technisch gezien zouden we zo een extra compiler naar TAM-code erbij kunnen doen, aangezien er geen andere reden is dan "omdat het kan" hebben we onszelf die moeite bespaard.\\
\\
Lees verder - of probeer eens een testprogramma te compileren in SELMA - om te leren hoe de vork nou precies in de steel zit met deze taal.\\
\\
\textit{- Mark \& Jeroen}


\newpage
\section{Problemen en oplossingen}
uitleg over de wijze waarop je de problemen die je bent tegenge-
komen bij het maken van de opdracht hebt opgelost (maximaal twee A4-tjes).

\newpage
\section{Syntax, context-beperkingen en semantiek}

%van de taal met waar nodig nadere uitleg over de
%betekenis. Geef de beschrijving bij voorkeur in dezelfde terminologie als die gebruikt is bij
%de beschrijving van Triangle in Watt \& Brown (hoofdstuk 1 en appendix B).

\subsection{Lexer - terminals}
Om de code te kunnen parsen zal deze eerst door de lexer moeten gaan. Hier definieren wij een aantal terminal symbolen. Dit is een eindige set van een aantal symbolen of woorden, de lexer zal deze herkennen. Mits ze in de juiste volgorde worden gebruikt krijg je taalconstructies die de parser vervolgens weer begrijpt. We hebben een aantal speciale terminals die zijn opgebouwd uit meerdere karakters bijvoorbeeld. Deze vormen de lexicon. En een drietal terminals zonder textuele vorm. Deze zijn enkel voor de interne boekhouding van de parser.
\\
\begin{lstlisting}[style=ANTLR]
CHARV		APOSTROPHE LETTER APOSTROPHE;
BOOLEAN		(TRUE | FALSE);
ID		LETTER (LETTER | DIGIT)*;
NUMBER		DIGIT+;
	
DIGIT		('0'..'9');
LOWER		('a'..'z');
UPPER		('A'..'Z');
LETTER		(LOWER | UPPER);
TRUE		'true';
FALSE		'false';

UMIN;
UPLUS;
COMPOUND;			
\end{lstlisting}

\newpage 

Verder zijn er nog de 'gewone' terminals. Te verdelen in keywords, tokens en operators. Keywords geven aan dat er een bepaalde actie gedaan wordt, zoals een variabele declareren of een if statement. Tokens zijn er om de taal iets meer structuur te geven, denk aan comma's tussen de variabelen. En operators zijn bewerkingen die je kunt uitvoeren op 1 of meer expressies.
\\
\begin{lstlisting}[style=ANTLR]
	Tokens			Keywords
	
COLON		':';	PRINT		'print';
SEMICOLON	';';	READ		'read';
LPAREN		'(';	VAR		'var';
RPAREN		')';	CONST		'const';
LCURLY		'{';	INT		'integer';
RCURLY		'}';	BOOL		'boolean';
COMMA		',';	CHAR		'character';
EQ		'=';	BEGIN		'begin';
APOSTROPHE	''';	END		'end.';
			IF		'if';
			THEN		'then';
			ELSE		'else';
			FI		'fi';
			WHILE		'while';
	Operators	DO		'do';
			OD		'od';
NOT		'!';	PROC		'procedure';
MULT		'*';	FUNC		'function';
DIV		'/';
MOD		'%';
PLUS		'+';
MINUS		'-';
RELS		'<';
RELSE		'<=';
RELGE		'>=';
RELG		'>';
RELE		'==';
RELNE		'<>';
AND		'&&';
OR		'||';
BECOMES		':=';
\end{lstlisting}
\newpage

\subsection{De basis - Programma}
De basis van het programma geeft een aantal restricties op aan de taal.
Allereerst is er het programma, dit bestaat uit een (zeer grote) compoundexpression waarna het programma stopt (End Of File). Deze wordt hier herschreven. Een compoundexpression is uiteindelijk opgebouwd uit een serie declaraties en statements, gescheiden door een semicolon. Hier is te zien dat het programma uit minimaal 1 expressie bestaat, dat declaraties en expressies door elkaar gebruikt mogen worden en dat het laatste statement in een programma altijd een expressie is.
\lstinputlisting[style=ANTLR,linerange={90-101}]{../g-files/SELMA.g}

\subsection{Expression\_statement}
Dit is een speciale tussenstap voor de interne boekhouding. Na elke semicolumn zal de mogelijk resterende waarde van de stack worden gepopped. Dit maakt dat er niet aan het eind van ons programma een hoop troep op de stack staat. Voorwaarde is wel dat er wordt bijgehouden wanneer een expression van het type void is, dan hoeft er namelijk niet gepopped te worden.
\lstinputlisting[style=ANTLR,linerange={126-128}]{../g-files/SELMA.g}

\subsection{Declaraties en types}
SELMA kent twee soorten waarden-declaraties, variabelen en constanten. SELMA staat toe om per declaratie meerdere identifiers te definieren. Bij de declaratie dien je het type van de te declareren waarde mee te geven. En bij een constante dien je uiteraard een waarde mee te geven.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={105-119}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Het gegeven type dient bij de constante overeen te komen met het type van de gegeven waarde.
\item Identifiers mogen niet eerder gedeclareerd zijn, in de huidige of bovenliggende scope.
\end{itemize}
\subsubsection{Semantiek}
Er zal ruimte gereserveerd worden voor de variabele en het adres wordt onthouden. Voor een constante geldt hetzelfde behalve dat dan ook direct de desbetreffende waarde op dat adres wordt gezet. Op het moment dat elders in het programma een verwijzing is naar deze gedeclareerde dan zal deze variabele of constante geladen worden.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
var i, x: integer;
const c: char = 'g';
const b,t: boolean = true;
\end{lstlisting}

\subsection{Functiedeclaratie}
SELMA kent ook nog een functie declaratie. Deze valt logischerwijs ook onder de declaraties. De declaratie van een functie dient altijd voor het gebruik te komen. Een functie kan als een soort procedure worden gebruikt door geen return-type op te geven. Het return-type wordt dan automatisch void. Dit hebben we express gedaan, we willen het namelijk altijd een functie noemen, aangezien procedures niet echt een plek hebben binnen een expressietaal.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={112-112,121-124}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De naam van de functie moet uniek zijn als functienaam, er mag wel een variabele of constante bestaan met die naam.
\item De opgegeven identifiers moeten allemaal een andere naam hebben, ze hoeven echter niet uniek te zijn binnen het programma aangezien ze in een aparte scope staan.
\item Het type van de expressie na het returntype dient hetzelfde te zijn als type.
\end{itemize}
\subsubsection{Semantiek}
Het adres waar deze functie staat wordt opgeslagen. Daarna komt de code van de functie. Aan het einde van de functie zal eventueel een result op de stack worden gezet en wordt het adres dat aan het begin is gegeven aangeroepen om weer terug te komen op de plek waar de functie werdt aangeroepen.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
function foo() {
	6*7;
}
function foo(awesome,less:boolean;bar:integer;): integer {
	var i: integer;
	
	if (awesome;) then
		i := 42;
	else
		i := 2;
	fi;
	
	return i;
}
\end{lstlisting}


\subsection{Expressies - assignment}
De expressies zijn ingedeeld in verschillende niveaus, dit om te zorgen dat ze in de juiste volgorde worden uitgevoerd. Zo willen we dat 6+3*12 niet 108 is maar 42, niet alleen om dat 42 een mooier getal is, maar voornamelijk omdat het fijn is als de taal voldoet aan de conventionele rekenregels. \\
Het hoogste niveau is de assignment.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={131-137}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_arithmetic moet een identifier worden, in het eind, aangezien dat het enige is waaraan je een waarde kunt toekennen
\item deze identiefier moet dan verwijzen naar een geldige variabele
\item het type van expression en expression\_arithmetic moet hetzelfde zijn
\item expression is van het type van expr\_assignment
\item expr\_assignment is van het type van expr\_arithmetic 
\end{itemize}
\subsubsection{Semantiek}
De waarde van expression zal worden toegekend aan het linker deel van de assignment.
Tevens gaat de waarde van de hele expressie op de stack, zo is er een asignement met meerdere identifiers mogelijk.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
foo := 7*6;
foo := bar := 7*6;
\end{lstlisting}

\subsection{Expressies - OR}
De Of-operator is de laagste operator in het rijtje, vandaar dat deze bovenin de structuur zit.
\\
NB: expr\_al1 staat voor "expression arithmetic level 1"
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={139-145}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Als expr\_al1 enkel uit 1 expr\_al2 bestaat dan zijn er geen restricties
\item In de andere gevallen dienen alle expr\_al2 van het type boolean te zijn.
\item het type van expr\_arithmetic is het type van expr\_al1
\item als exp\_1 == expr\_al2 dan is het type van expr\_al1 het type van expr\_al2
\item als exp\_1 != expr\_al2 dan is het type van expr\_al1 een boolean
\end{itemize}
\subsubsection{Semantiek}
De eerste expr\_al2 zal op de stack worden gezet. Hierna wordt er telkens een expr\_al2 erbij gezet. De OR-operatie zal worden aangeroepen en het resultaat blijft op de stack zijn. Als er nog een expr\_al2 is dan zal deze ook op de stack worden gezet en wordt de OR-operatie opnieuw aangeroepen. Aldoende blijft er uiteindelijk 1 waarde op de stack staan.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
true OR false;
true OR false OR foo;
\end{lstlisting}

\subsection{Expressies - AND}
Hier wordt de AND-expressie beschreven. Net zoals bij de OR-expressie is het mogelijk nul tot veel AND-operatoren achter elkaar te plakken. De AND-expressie is een niveau hoger dan de OR-expressie en zal dus eerder worden uitgevoerd. \\
Het is eventueel mogelijk later in de compiler om een AND eerder af te breken aangezien als er een false in het rijtje zit het resultaat altijd false is. Wij hebben deze optimalisatie er nog niet inzitten, dit omdat sommige expressies ongeacht de eerdere expressies uitgevoerd dienen te worden, denk bijvoorbeeld aan een READ()-statement dat anders niet uitgevoerd zou worden.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={147-149}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Als expr\_al2 enkel uit 1 expr\_al3 bestaat dan zijn er geen restricties
\item In de andere gevallen dienen alle expr\_al3 van het type boolean te zijn.
\item als exp\_2 == expr\_al3 dan is het type van expr\_al2 het type van expr\_al3
\item als exp\_2 != expr\_al3 dan is het type van expr\_al2 een boolean
\end{itemize}
\subsubsection{Semantiek}
Hetzelfde als bij het OR-statement. De waardes zullen op de stack geladen worden en er zal telkens een AND-operatie op 2 waardes worden uitgevoerd. De resulterende waarde is weer geschikt voor bijvoorbeeld nog een AND-operatie.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
foo AND bar;
foo AND false AND bar;
\end{lstlisting}

\subsection{Expressies - Relaties}
Hier worden bijna alle comperatoren afgehandeld. Het is belangrijk dat er in de checker goed wordt gekeken of de types van de linker en rechterzijde compatible zijn.
\subsubsection{Syntax}
%		: expr_al4 ((RELS|RELSE|RELG|RELGE|RELE|RELNE)^ expr_al4)*
\lstinputlisting[style=ANTLR,linerange={151-153}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item alle expr\_al4 dienen van hetzelfde type te zijn
\item bij een operatie tussen twee expr\_al4 anders dan RELE \& RELNE dient expr\_al4 een integer te zijn.
\item als exp\_3 == expr\_al4 dan is het type van expr\_al3 het type van expr\_al4
\item als exp\_3 != expr\_al4 dan is het type van expr\_al3 een boolean
\end{itemize}
\subsubsection{Semantiek}
Vergelijkbaar met andere binaire operatoren zoals AND en OR, er zullen waardes op de stack worden gezet en de operatie zal 1 waarde achterlaten op de stack.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
5 > 6;
true == false;
5 == 42;
\end{lstlisting}

\subsection{Expressies - plus en minus}
Hier zijn we aangeland bij de eerder genoemde 6+3*12, plus en minus zit 1 niveau lager dan de vermenigvuldigingen.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={155-157}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item als er minimaal 1 operatie wordt uitgevoerd dan dient expr\_al5 een integer te zijn
\item als exp\_4 == expr\_al5 dan is het type van expr\_al4 het type van expr\_al5
\item als exp\_4 != expr\_al5 dan is het type van expr\_al4 een integer
\end{itemize}
\subsubsection{Semantiek}
Wederom een binaire operatie. Let op, de unaire plus en minus komen nog. Dus 5--6 zal de tweede minus niet hier worde opgevangen.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo := 5;
foo := 5 + 37;
10 + 50 - 18;
\end{lstlisting}

\subsection{Expressies - delen en vermenigvuldigen}
Naast delen en vermenigvuldigen is het ook mogelijk een modulus te nemen.
Wat wellicht is opgevallen bij het bovenstaande, is dat het mogelijk is om enkel een som in de code te zetten. Dit vinden wij prima, echter moet daarbij wel de resulterende waarde gepopped worden als die niet meer gebruikt wordt.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={159-161}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item als er minimaal 1 operatie wordt uitgevoerd dan dient expr\_al6 een integer te zijn
\item als exp\_5 == expr\_al6 dan is het type van expr\_al5 het type van expr\_al6
\item als exp\_5 != expr\_al6 dan is het type van expr\_al5 een integer
\end{itemize}
\subsubsection{Semantiek}
Hetzelfde als bij optellen. Goed om te weten is dat de geretouneerde waarde een integer is, dus er zal worden afgerond.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo := 6;
foo := 6*7;
foo := 21*6%84;
\end{lstlisting}


\subsection{Expressies - unaries}
Hier wordt gekeken of de expressie eventueel een NOT-, PLUS- of MIN-operator voor zich heeft staan.
Om later verwarring te voorkomen zullen PLUS en MIN vervangen worden door speciale terminals, zijnde UMIN en UPLUS. UPLUS zou eventueel weg kunnen worden gelaten aangezien +x==x.
Als er geen operator voor de expressie staat dan is expr\_al6 gewoon een expr\_al7
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={163-171}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_al7 dient bij PLUS expr\_al7 een integer te zijn
\item expr\_al7 dient bij MIN expr\_al7 een integer te zijn
\item expr\_al7 dient bij NOT expr\_al7 een boolean te zijn
\item het type van expr\_al6 het type van expr\_al7
\end{itemize}
\subsubsection{Semantiek}
Bij UMIN zal expr\_al6 == - expr\_al7 \\
Bij UPLUS zal expr\_al6 == expr\_al7 \\
Bij NOT zal expr\_al6 == ! expr\_al7 
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
one := +1;
evil := -42;
foo := not foobar;
\end{lstlisting}

\subsection{Expressies - toplevel}
Op het hoogste nivau kan een expressie bestaan uit een semi-statement zoals een if-expressie of een print-expressie, of het kan een identifier of waarde zijn, of het kan een aparte (compound)expressie binnen haken zijn.
Zoals je ziet stond in eerste de assignment hier. Maar aangezien het meest linkerdeel van een assignment een identiefier is kan op L=1 geen onderscheid worden gemaakt tussen identifier of een assignment. Vandaar dat een assignment bij expr\_al1 is gedefineerd.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={173-184}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_al7 is van hetzelfde type als de gegeven expressie of waarde.
\end{itemize}
\subsubsection{Semantiek}
Dit is enkel een lijst van mogelijke expressies en waardes en dus zal er in de compiler enkel deze expressie of waarde op stack hebben staan, maar wordt er geen operatie op uitgevoerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo;
42;
(foobar);
\end{lstlisting}

\subsection{Unsigned constants}
Uiteraard bied onze taal ook de mogelijkheid aan om constanten te gebruiken zonder deze eerst te moeten declareren. Oftewel, je kunt gewoon nummers gebruiken bijvoorbeeld.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={214-230,236-238}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item unsignedconstant is van het type van de gegeven waarde
\item boolval is een boolean type
\item charval is een char
\item intval is een integer
\end{itemize}
\subsubsection{Semantiek}
De desbetreffende waarde wordt op de stack gezet.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
'Y';
42;
true;
\end{lstlisting}

\subsection{Identifier}
Een identifier van een bestaande variabele of constante in de huidige of een hogere scope.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={231-234,245-247}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De identifier dient te verwijzen naar een geldige variabele of constante
\item Het type is het type van de variabele of declaratie waar de identifier naar verwijst.
\end{itemize}
\subsubsection{Semantiek}
Er zal een commando aangeroepen worden om de waarde uit het geheugen te laden. Deze waarde wordt dan op de stack gezet. Bij constanten gebeurd dit ook. Eventueel zou je ook de constante zelf al kunnen neerzetten op de stack, dit scheelt weer wat werk voor de processor. Dit doen wij echter niet momenteel.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
Answer42;
\end{lstlisting}

\subsection{Read}
Om contact te hebben met de buitenwereld kan onze taal lezen en schrijven naar de standard-out. 
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={185-187}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Identifier dient te verwijzen naar een geldige identifier
\item De ingelezen waarde dient van het zelfde type als identifier te zijn
\item Als er 1 identifier is opgegeven dan geeft read de gelezen waarde/type terug
\item Als er meer dan 1 identifier wordt ingelezen dan is het returntype void
\end{itemize}
\subsubsection{Semantiek}
Het read-commando wordt aangeroepen en de waarde wordt van de standard-out gelezen en op de stack gezet. Vervolgens wordt die waarde opgeslagen in de variabele.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
read(foo);
read(foo,bar);
\end{lstlisting}

\subsection{Print}
De taal heeft ook de mogelijkheid om dat wat er bijvoorbeeld berekend is naar buiten te communiceren.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={189-192}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item -
\end{itemize}
\subsubsection{Semantiek}
De waarde van de expressie staat op de stack. Vervolgens wordt deze netjes naar het scherm uitgevoerd. Afhankelijk van het type zal dat anders gebeuren. 
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
print(42);
print('4','2');
\end{lstlisting}

\subsection{If}
Om keuzes in het programma mogelijk te maken zal er een conditioneel statement nodig zijn, het IF-statement is een dergelijk statement. Een ELSE-deel is optioneel.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={193-195}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De eerste compoundexpression moet een boolean-type retouneren
\item De if retouneerd een type void
\todo{retourtype}
\end{itemize}
\subsubsection{Semantiek}
Als de waarde binnen het ifstatement waar is dan zal de eerste compoundexpressie worden uitgevoerd (na de then). Anders zal de andere compoundexpressie worden uitgevoerd, mits deze is gedeclareerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
if true; then i := 42; fi
if false; then i := 0; else i:=42; fi
\end{lstlisting}

\subsection{While}
De while zal net zolang een blok code uitvoeren tot een gegeven expressie waar is.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={197-199}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De eerste compoundexpression moet een boolean-type retouneren
\item De while retouneerd een type void
\end{itemize}
\subsubsection{Semantiek}
De tweede compoundexpression zal worden uitgevoerd tot de eerste compoundexpression waar is. Het kan zijn dat de tweede compoundexpression nooit wordt uitgevoerd dus.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
while false; do 
\\ this is not gonna be executed
tru := false;
od

while foo<5; do
foo := foo + 1;
od
\end{lstlisting}

\subsection{Functieaanroep}
Een functieaanroep naar een eerder gedefineerde functie
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={201-203}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Het aantal expressies en hun type dient overeen te komen met de declaratie van de functie
\item De functie retouneert het eerder gespecificeerde type. Als er geen type was gedeclareerd dan is dat dus void.
\end{itemize}
\subsubsection{Semantiek}
Het returnadres wordt op de stack gezet, zodat de functie weer hiernaartoe kan terugkeren.
De expressies worden op de stack gezet in de gespecificeerde volgorde.
De functie wordt aangeroepen.
De functie returned en het result staat op de stack.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo();
i := foo('b','a','r');
\end{lstlisting}


\subsection{Closed expression}
Een expressie tussen haakjes is soms handig, bijvoorbeeld bij sommetjes: (5+2)*6;
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={209-211}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De geretouneerde waarde zal de waarde van de expressie zijn binnen de haakjes.
\item Het retourneerde type is ook hetzelfde als die van de expressie.
\end{itemize}
\subsubsection{Semantiek}
De expressie binnen de haakjes zal worden uitgevoerd binnen de haakjes.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
(3*(6+8))%102;
\end{lstlisting}

\subsection{Closed compoundexpression}
Is een compoundexpressie binnen haakjes. Verschil met de expressie tussen haakjes is dat deze ook toestaat om declaraties te gebruiken. Een compound tussen haakjes zal een eigen scope hebben.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={205-207}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item retouneerd het waarde en de type van de laatste expressie in de compound, dit kan van het type void zijn.
\end{itemize}
\subsubsection{Semantiek}
De compoundexpressie zal in een eigen scope worden uitgevoerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
{
var foo: integer;
foo := 40;
foo+2;
}
\end{lstlisting}


\todo{expression\_statement}

%
%expression_statement
%	: expression SEMICOLON
%		-> ^(EXPRESSION_STATEMENT expression)
%	;
%


%==================================OPMAAK======================================

%\subsection{Expressies - }
%
%\subsubsection{Syntax}
%\lstinputlisting[style=ANTLR,linerange={131-137}]{../g-files/SELMA.g}
%\subsubsection{Context}
%\begin{itemize}
%\item
%\end{itemize}
%\subsubsection{Semantiek}
%
%\subsubsection{Voorbeeld}
%\begin{lstlisting}[style=SELMA]
%\end{lstlisting}

%==================================OPMAAK======================================

\newpage
\section{Vertaalregels}
voor de taal, d.w.z. de transformaties waaruit blijkt op welke wijze een opeen-
volging van symbolen die voldoet aan een produktieregel wordt omgezet in een opeenvol-
ging van TAM-instructies. Vertaalregels zijn de ‘code templates’ van hoofdstuk 7 van Watt
\& Brown.

\newpage
\section{Beschrijving van Java programmatuur}
%Beknopte bespreking van de extra Java klassen die
%u gedefinieerd heeft voor uw compiler (b.v. symbol table management, type checking, code
%generatie, error handling, etc.). Geef ook aan welke informatie in de AST-nodes opgeslagen
%wordt.
%
%
%CheckerEntry.java    SELMA.java
%CompilerEntry.java   SELMATreeAdaptor.java
%IdEntry.java         SELMATree.java
%SELMAException.java  SymbolTable.java
\subsection{main - SELMA}
SELMA.java is het main-programma. Je kunt een aantal opties en een SELMA-sourcecodefile meegeven.
Hierna zal SELMA desbetreffende file parsen en compileren. De opties die mogelijk zijn zijn:
\begin{itemize}
\item -ast Er zal een ast-diagram naar de stdOut worden geprint van de source-code.
\item -dot Er zal een dot-diagram naar de stdOut worden geprint van de source-code.
\item -no\_checker De source-code wordt geparsed maar niet gechecked.
\item -code\_generator De source-code zal worden gecompiled
\end{itemize}
De sourcecode zal de volgende stappen doorlopen: \\
\begin{tabbing}
\hspace{5em}\=\hspace{5em}\=\hspace{7em}\=\hspace{5em}\=\hspace{10em}\=\kill
Lexer \>  Parser \> -no\_checker 	\>   		\> -ast \>  Ast-diagram \\
Lexer \>  Parser \> -no\_checker 	\>   		\> -dot \>  Dot-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -ast \>  Ast-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -dot \>  Dot-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -code\_generator \>  Code 
\end{tabbing} 
Alle resultaten zullen altijd naar de stdOut worden geprint.

\subsection{SELMAException}
Als er wat fout gaat in bijvoorbeeld de checker dan zal er een exception worden gegooid. Deze exception is een SELMAException. Aan de exception wordt de node meegegeven waar de checker op dat moment mee bezig is. En de toString()-functie van SELMAException zal dat dan ook mooi formatten in de vorm van "(regelnummer:columnnummer) Errormessage", toch wel fijn als je moet debuggen. 

\subsection{SELMATreeAdaptor}
Deze TreeAdaptor heeft SELMATree als nodes, in plaats van een normale Tree.

\subsection{SELMATree}
SELMATree is een uitbreiding op de normale tree. En kan een aantal extra dingen bijhouden, namelijk of een expressie constant is of variabel, wat later handig is voor optimizing. En wat het type is van de expressie, dat is zeer handig voor de checker.
Daarvoor heeft SELMATree een paar extra attributen, zijnde:
\lstinputlisting[style=JAVA,linerange={26-30}]{../src/SELMA/SELMATree.java}
En verder kent SELMATree nog drie functies om mooi te kunnen printen:
\lstinputlisting[style=JAVA,linerange={32-32,36-36,68-68}]{../src/SELMA/SELMATree.java}

\subsection{SymbolTable}
De symboltable houdt al onze variabelen en constanten bij. Ook kun je in de symboltable scopes aanmaken, om bijvoorbeeld variabelen binnen een compoundexpressie te kunnen declareren. De dataopslag van de symboltable geschiedt middels een Map waarin een string aan een stack van IDEntries wordt gekoppeld. De string verwijst naar de naam van de variabele of constante. De stack bevat meerdere declaraties van die variabele met die naam in verschillende scopes. Zodat het mogelijk is de zelfde naam tweemaal te gebruiken, mits ze in een andere scope gebruikt worden.\\
\\
De symboltable kent een aantal functies, de belangrijkste zijn:
\lstinputlisting[style=JAVA,linerange={28-32,36-42,58-66,88-94}]{../src/SELMA/SymbolTable.java}

\subsubsection{SymbolTableException}
SymbolTableException is er om fouten in de symboltable aan te geven. Deze fouten zullen vergelijkbaar worden geformat als die van SELMAException, namelijk "(line:column) ErrorMsg.

\subsection{IDEntry}
De symboltable bevat voor elke variabele of constante een IDEntry. Een IDEntry bevat de scopelevel van desbetreffende declaratie. Wij gebruiken in onze code echter een tweetal klasses die ge-extend zijn op IDEntry; CheckerEntry en CompilerEntry.

\subsection{CheckerEntry}
De CheckerEntry wordt gebruikt in de Checker. Een checkerEntry verschilt van een IDEntry op het punt dat een checkerEntry twee extra waardes heeft om bij te houden wat het type is van de variabele of constante (int,bool of char). De tweede waarde is om bij te houden of we met een constante of een variabele te maken hebben.
\lstinputlisting[style=JAVA,linerange={7-8}]{../src/SELMA/CheckerEntry.java}

\subsection{CompilerEntry}
De compilerEntry is weer een uitbreiding op de CheckerEntry. Voor de compiler is het namelijk noodzakelijk om te weten op welk adres in de te genereren code de variabele staat. Dit wordt bijgehouden door:
\lstinputlisting[style=JAVA,linerange={7-7}]{../src/SELMA/CompilerEntry.java}

\newpage
\section{Testplan en -resultaten}
Bespreking van de ‘correctheids-tests’ aan de hand van de criteria
zoals deze zijn beschreven in het §A.5 van deze appendix. Aan de hand van deze criteria moet
een verzameling test-programma’s in het taal geschreven worden die de juiste werking van de
vertaler en interpreter controleren. Tot deze test-set behoren behalve correcte programma’s
die de verschillende taalconstructies testen, ook programma’s met syntactische, semantische
en run-time fouten.
Alle uitgevoerde tests moeten op de CD-R aanwezig zijn; van een testprogramma moet de
uitvoer in de appendix opgenomen worden (zie onder).

\newpage
\section{Conclusies}



\newpage
\section{Appendix}

\subsection{ANTLR Lexer \& Parser specificatie}
%Specificatie van de invoer voor de ANTLR scanner generator,
%d.w.z. de token-definities van het taaltje.

%Specificatie van de invoer voor de parser generator, d.w.z. de
%structuur van de taal en de wijze waarop de AST gegenereerd wordt
\lstinputlisting[style=ANTLRfile]{../g-files/SELMA.g}

\newpage
\subsection{ANTLR Checker specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMAChecker.g}

\newpage
\subsection{ANTLR Codegenerator specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMACompiler.g}

\begin{landscape}
\newpage
\subsection{ANTLR Codegenerator Stringtemplate specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMACodeJasmin.stg}
\end{landscape}

\newpage
\subsection{Invoer- en uitvoer van een uitgebreid testprogramma}
Van een correct en uitgebreid test-
programma (met daarin alle features van uw programmeertaal) moet worden bijgevoegd: de
listing van het oorspronkelijk programma, de listing van de gegenereerde TAM-code (be-
standsnaam met extensie .tam) en een of meer executie voorbeelden met in- en uitvoer
waaruit de juiste werking van de gegenereerde code blijkt.


\end{document}