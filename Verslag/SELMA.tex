\documentclass[]{article}

\title{SELMA}
\author{
Vonk, J\\
(herhaler)\\
s0132778\\
Matenweg 75-201\\
\\
Florisson, M\\
(herhaler)\\
s0165972\\
Box Calslaan 60-30\\
\\
Studentassistent:\\
Edwin Smulders}

\usepackage{listings}
\usepackage{lscape}
\usepackage{color}
\usepackage[pdftex,bookmarks=true]{hyperref}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{url}
% \usepackage[T1]{fontenc}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\begin{document}

\lstdefinestyle{ANTLR}
	{frame=shadowbox, breaklines=true,basicstyle=\footnotesize}
\lstdefinestyle{SELMA}
	{frame=shadowbox, breaklines=true,basicstyle=\small}
\lstdefinestyle{JAVA}
	{frame=shadowbox, language=Java, breaklines=true,basicstyle=\footnotesize}
\lstdefinestyle{JVM}
	{frame=shadowbox, breaklines=true,basicstyle=\small}
\lstdefinestyle{ANTLRfile}
	{frame=LB, breaklines=true, basicstyle=\scriptsize, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}
\lstdefinestyle{SELMAfile}
	{frame=LB, breaklines=true, basicstyle=\scriptsize, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}
\lstdefinestyle{JAVAfile}
	{frame=LB, language=Java, breaklines=true, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}
\lstdefinestyle{JVMfile}
	{frame=LB, breaklines=true, numbers=left, stepnumber=5, firstnumber=1, numberstyle=\tiny}

\newcommand{\todo}[1]{\marginpar{\fcolorbox{red}{yellow}{\textbf{#1}}}}



\begin{titlepage}
\maketitle
\end{titlepage}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\tableofcontents{}

\newpage
\section{Inleiding}
%Korte beschrijving van de practicumopdracht.
Voor vertalerbouw dient als eindopdracht een eigen taal geschreven te worden. Deze taal dient een expression-language te zijn, dit is een taal die geen statements, maar enkel expressies kent. Alles wat je dus aanroept zal een waarde teruggeven.\\
Voor deze zelfbedachte taal dient een parser en lexer geschreven te worden, een checker en een compiler. Hierbij dient een verslag met een uitgebreide beschrijving van de taal en een goede kijk op hoe alles onder de motorkap werkt. Ook moet er een bewijs worden geleverd dat de taal werkt, dit kan door een testprogramma te schrijven dat tamelijk uitgebreid is en te kijken of dit werkt naar behoren. (black-box testing) \\
Hoe uitgebreid de te definieren taal wordt is aan de studenten zelf - dit is echter terug te zien in het te behalen cijfer.\\
Voor onze taal, SELMA, hebben wij gekozen voor het volgende:

\begin{itemize}
\item Basic Expression Language
\item If- \& while-statements
\item Ondersteunen van functies
\item Compileren naar JVM-code in plaats van TAM-code
\end{itemize}

Onze taal heet SELMA. Een naam aan een taal geven is lastig, zo waren er een aantal andere opties zoals: SMEF of Taal voor Vertalerbouw (TV).
De SEL staat voor Simpel Expression Language. Nu moest de afkorting wat meer zeggen dus kozen we voor de meisjesnaam SELMA, alleen maar omdat een afkorting vinden voor SELDERIE wel heel veel werk is.\\
Gelukkig heet onze taal dus geen SELDERIE, maar SELMA:\\
Waarbij de MA voor Minor Adjustments stond, we hebben inmiddels zoveel werk eraan gehad dat "Minor" dat geen eer meer aan doet. \\
Dus met gepaste trots presenteren wij u SELMA:\\
Simple Expression Language Met Augurk\\
Vanaf nu enkel nog naar te verwijzen als SELMA.\\

\newpage
\section{Beknopte beschrijving}
%van de programmeertaal (maximaal een A4-tje).
Onze taal is gemaakt naar de gegeven instructies van de practicumhandleiding en alles is of een expressie of declaration in deze taal. Bij sommige expressies is het echter niet mogelijk een resultaat te geven, hier kunnen die expressies niet anders dan een void-resultaat retouneren, wat ze effectief een statement maakt. De structuur van de taal en de keywords lijken qua layout op een hybride tussen C en Pascal. \\
De volledige taal is LL(1) wij hebben hierdoor vooral tijdens het ontwerpen goed moeten nadenken hoe we de taal zo logisch mogelijk opbouwden zodat de parser er mee uit de voeten kon. Eventueel is er de mogelijkheid om lokaal 1 stap verder te kijken, wij hebben dit echter niet nodig gehad omdat wij voldoende keywords hebben gebruikt, zoals voor een functie een @ zetten - en we in de parser bewust rekening hebben gehouden met de LL(1) limitatie.\\
\\
SELMA compileerde in eerste instantie naar TAM, op de cd is een fragment van deze code te zien. We hebben echter besloten dat het mooier was om JVM te gebruiken, niet zo zeer uit praktisch oogpunt, maar meer omdat JVM-bytecode ook door "echte" talen wordt gebruikt en omdat het een pluspunt is in de eindbeoordeling.\\
Op het moment dat we besloten om te schakelen waren we blij dat we hadden gekozen voor het gebruik van stringTemplates bij de codegeneratie, dit heeft ons wat werk gescheeld. En technisch gezien zouden we zo een extra compiler naar TAM-code erbij kunnen doen, aangezien er geen andere reden is dan "omdat het kan" hebben we onszelf die moeite bespaard.\\
\\
Lees verder - of probeer eens een testprogramma te compileren in SELMA - om te leren hoe de vork nou precies in de steel zit met deze taal.\\
\\
\\
\textit{- Mark \& Jeroen}\\
\\
NB: Aangezien CD's lang niet zo hip zijn als wat het internet heeft te bieden is ons gehele werk \'{o}\'{o}k te vinden op github: \\
\\
\url{http://github.com/markflorisson88/selma/}


\newpage
\section{Problemen en oplossingen}
%uitleg over de wijze waarop je de problemen die je bent tegenge-
%komen bij het maken van de opdracht hebt opgelost (maximaal twee A4-tjes).
Tijdens het maken van de taal zijn we uiteraard af en toe tegen problemen aangelopen. Nu hebben wij tijdens het practicum de calc-taal al ontwikkeld dus we hadden al wat handigheid met ANTLR - en ANTLR's soms wat aparte foutmeldingen.\\
\subsection{Taalconstructie}
Wat ons is opgevallen is dat je van te voren goed moet specificeren hoe je taal er uit moet zien. Door bijvoorbeeld onze keuze om overal SEMICOLON's achter te zetten - wat op zich logisch is - kregen we soms wat onwennige taalconstructies. Zo dien je ook een semicolon na een functiedeclaratie te zetten, want het is een declaratie - en ook een semicolon na een if-expressie voelt wat ongebruikelijk. Omdat echter alles een expressie is in deze taal vonden we het passend hier geen uitzonderingen op te gaan maken door sommige expressies niet met een semicolon af te sluiten. \\
De eis om een taal LL(1) te maken heeft echter niet echt problemen opgeleverd, behalve dat we de declaratie voor een assignment op een andere plek wouden doen in eerste instantie (onder expressies-toplevel), hierbij was echter met LL(1) geen onderscheid te maken tussen een identifier en een assignment.\\
Een ander punt waar het onderscheid moeilijk was, waren functies. Deze zijn namelijk niet te onderscheiden van identifiers, tot je een haakje-openen na een identifier ziet. We hebben overwogen om een lokale forward-lookup te gebruiken, dit hebben we echter snel bestempeld als "slim valsspelen" en we hebben een '@' voor alle functie-aanroepen gezet. Klinkt ook mooi, aangezien je ook daadwerkelijk verwijst naar een stuk eerder gedefineerde code.\\
Soms was het noodzakelijk om een stevige herschrijfregel te gebruiken, om in de checker en compiler wat meer gemak te hebben. Zo hebben we UMIN en EXPRESSION\_STATEMENT toegevoegd. En hebben we vormen zoals (ID (COMMA ID)* COLON type) naar \^(ID TYPE)+ omgeschreven.
\subsection{Checker}
De checker heeft vrijwel geen problemen opgeleverd, aangezien onze randcode - Java-helperclasses etc. - gewoon netjes aansloot en een hoop werk uit handen nam.\\
Waar we wel consequent tegenaan liepen waren de wat vage manieren waarop er data uit de boom te halen is. Dollartekens voor Tokens, of juist niet, het was soms wat onduidelijk.
\subsection{Compiler}
In eerste instantie is de compiler in TAM geschreven, toen het echter een project van 2 werdt in plaats van 1, is er besloten om een tandje bij te zetten en SELMA in een wat algemener geaccepteerde code-vorm te compilen: JVM.\\
\subsubsection{Jasmin \& JVM}
Er waren niet echt problemen met Jasmin of met de JVM. Een hindernis was het gebrek aan closures en global scope, dus om globale variabelen beschikbaar te maken tot functies moeten deze (statische) velden gemaakt worden en speciaal behandeld worden bij het laden van identifiers of assignment daaraan. Dit was vooral vervelend door het grote ongemak van string templates.\\
\subsubsection{String Templates}
String Templates is niet de meest flexibele template library. De syntax is raar en de restricties zijn enorm. Zo is het niet mogelijk een simpele comparison te doen in een 'if', en moet je dus een hoop booleans als argumenten meegeven (of wellicht een object de template in sturen met de juiste getters). Er is ook geen enkele mogelijkheid voor insertion points (e.g. code op bepaalde plekken te genereren, in plaats van "op de huidige positie"). Dit was vooral een probleem met functies, waarvoor we nieuwe methoden genereren die buiten de \texttt{main} methode moeten komen te staan. Hiervoor hebben we in \texttt{SELMA.java} een simpele vorm van post-processing gedaan waarbij we methoden in methoden buiten methoden zetten, zodat we een platte hierarchy krijgen.
\subsection{Randcode}
De randcode is deels gebaseerd op de symboltables gebruikt tijdens het practicum en neemt een hoop werk uit handen. De symboltable-entries zijn per onderdeel (checker,compiler) anders. Dit omdat we merkten dat er soms te weinig gegevens waren over declaraties. \\
In de boom zelf konden we ook niet genoeg info kwijt, vandaar dat we een extension op de normale Tree hebben gemaakt, SELMATree, waarin is op te slaan wat het type is van elke expressie en of er variabele onderdelen in een expressie zitten.

\newpage
\section{Syntax, context-beperkingen en semantiek}

%van de taal met waar nodig nadere uitleg over de
%betekenis. Geef de beschrijving bij voorkeur in dezelfde terminologie als die gebruikt is bij
%de beschrijving van Triangle in Watt \& Brown (hoofdstuk 1 en appendix B).

\subsection{Lexer - terminals}
Om de code te kunnen parsen zal deze eerst door de lexer moeten gaan. Hier definieren wij een aantal terminal symbolen. Dit is een eindige set van een aantal symbolen of woorden, de lexer zal deze herkennen. Mits ze in de juiste volgorde worden gebruikt krijg je taalconstructies die de parser vervolgens weer begrijpt. We hebben een aantal speciale terminals die zijn opgebouwd uit meerdere karakters bijvoorbeeld. Deze vormen de lexicon. En een zestal terminals zonder textuele vorm. Deze zijn enkel voor de interne boekhouding van de parser.
\\
\begin{lstlisting}[style=ANTLR]
CHARV		APOSTROPHE LETTER APOSTROPHE;
BOOLEAN		(TRUE | FALSE);
ID		LETTER (LETTER | DIGIT)*;
NUMBER		DIGIT+;

DIGIT		('0'..'9');
LOWER		('a'..'z');
UPPER		('A'..'Z');
LETTER		(LOWER | UPPER);
TRUE		'true';
FALSE		'false';

UMIN;
UPLUS;
BEGIN;
END;
COMPOUND;
EXPRESSION_STATEMENT;
\end{lstlisting}

\newpage

Verder zijn er nog de 'gewone' terminals. Te verdelen in keywords, tokens en operators. Keywords geven aan dat er een bepaalde actie gedaan wordt, zoals een variabele declareren of een if statement. Tokens zijn er om de taal iets meer structuur te geven, denk aan comma's tussen de variabelen. En operators zijn bewerkingen die je kunt uitvoeren op 1 of meer expressies.
\\
\begin{lstlisting}[style=ANTLR]
	Tokens			Keywords

COLON		':';	PRINT		'print';
SEMICOLON	';';	READ		'read';
LPAREN		'(';	VAR		'var';
RPAREN		')';	CONST		'const';
LCURLY		'{';	INT		'integer';
RCURLY		'}';	BOOL		'boolean';
COMMA		',';	CHAR		'character';
EQ		'=';	BEGIN		'begin';
APOSTROPHE	''';	END		'end.';
UNDERSCORE	'_';	IF		'if';
			THEN		'then';
			ELSE		'else';
			FI		'fi';
			WHILE		'while';
	Operators	DO		'do';
			OD		'od';
NOT		'!';	FUNCDEF		'function';
MULT		'*';	FUNCRETURN	'return';
DIV		'/';	FUNCTION	'@';
MOD		'%';
PLUS		'+';
MINUS		'-';
RELS		'<';
RELSE		'<=';
RELGE		'>=';
RELG		'>';
RELE		'==';
RELNE		'<>';
AND		'&&';
OR		'||';
BECOMES		':=';
\end{lstlisting}
\newpage

\subsection{De basis - Programma}
De basis van het programma geeft een aantal restricties op aan de taal.
Allereerst is er het programma, dit bestaat uit een (zeer grote) compoundexpression waarna het programma stopt (End Of File). Deze wordt hier herschreven. Een compoundexpression is uiteindelijk opgebouwd uit een serie declaraties en statements, gescheiden door een semicolon. Hier is te zien dat het programma uit minimaal 1 expressie bestaat, dat declaraties en expressies door elkaar gebruikt mogen worden en dat het laatste statement in een programma altijd een expressie is.
\lstinputlisting[style=ANTLR,linerange={100-111}]{../g-files/SELMA.g}

\subsection{Expression\_statement}
Dit is een speciale tussenstap voor de interne boekhouding. Na elke semicolumn zal de mogelijk resterende waarde van de stack worden gepopped. Dit maakt dat er niet aan het eind van ons programma een hoop troep op de stack staat. Voorwaarde is wel dat er wordt bijgehouden wanneer een expression van het type void is, dan hoeft er namelijk niet gepopped te worden.
\lstinputlisting[style=ANTLR,linerange={146-148}]{../g-files/SELMA.g}

\subsection{Declaraties en types}
SELMA kent twee soorten waarden-declaraties, variabelen en constanten. SELMA staat toe om per declaratie meerdere identifiers te definieren. Bij de declaratie dien je het type van de te declareren waarde mee te geven. En bij een constante dien je uiteraard een waarde mee te geven.
De functie declaratie die je ziet staan wordt apart besproken.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={115-129}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Het gegeven type dient bij de constante overeen te komen met het type van de gegeven waarde.
\item Identifiers mogen niet eerder gedeclareerd zijn, in de huidige of bovenliggende scope.
\end{itemize}
\subsubsection{Semantiek}
Er zal ruimte gereserveerd worden voor de variabele en het adres wordt onthouden. Voor een constante geldt hetzelfde behalve dat dan ook direct de desbetreffende waarde op dat adres wordt gezet. Op het moment dat elders in het programma een verwijzing is naar deze gedeclareerde dan zal deze variabele of constante geladen worden.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
var i, x: integer;
const c: char = 'g';
const b,t: boolean = true;
\end{lstlisting}

\subsection{Functiedeclaratie}
SELMA kent ook nog een functie declaratie. Deze valt logischerwijs ook onder de declaraties. De declaratie van een functie dient altijd voor het gebruik te komen. Een functie kan als een soort procedure worden gebruikt door geen return-type op te geven. Het return-type wordt dan automatisch void. Dit hebben we express gedaan, we willen het namelijk altijd een functie noemen, aangezien procedures niet echt een plek hebben binnen een expressietaal.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={122-122,131-134}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De naam van de functie moet uniek zijn.
\item De opgegeven identifiers moeten allemaal een andere naam hebben, ze hoeven echter niet uniek te zijn binnen het programma aangezien ze in een aparte scope staan.
\item Het type van de expressie na het returntype dient hetzelfde te zijn als type.
\end{itemize}
\subsubsection{Semantiek}
Het adres waar deze functie staat wordt opgeslagen. Daarna komt de code van de functie. Aan het einde van de functie zal eventueel een result op de stack worden gezet en wordt het adres dat aan het begin is gegeven aangeroepen om weer terug te komen op de plek waar de functie werdt aangeroepen.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
function foo() {
	6*7;
}
function foo(awesome,less:boolean;bar:integer;): integer {
	var i: integer;

	if (awesome;) then
		i := 42;
	else
		i := 2;
	fi;

	return i;
}
\end{lstlisting}


\subsection{Expressies - assignment}
De expressies zijn ingedeeld in verschillende niveaus, dit om te zorgen dat ze in de juiste volgorde worden uitgevoerd. Zo willen we dat 6+3*12 niet 108 is maar 42, niet alleen om dat 42 een mooier getal is, maar voornamelijk omdat het fijn is als de taal voldoet aan de conventionele rekenregels. \\
Het hoogste niveau is de assignment.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={151-157}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_arithmetic moet een identifier worden, in het eind, aangezien dat het enige is waaraan je een waarde kunt toekennen
\item deze identiefier moet dan verwijzen naar een geldige variabele
\item het type van expression en expression\_arithmetic moet hetzelfde zijn
\item expression is van het type van expr\_assignment
\item expr\_assignment is van het type van expr\_arithmetic
\end{itemize}
\subsubsection{Semantiek}
De waarde van expression zal worden toegekend aan het linker deel van de assignment.
Tevens gaat de waarde van de hele expressie op de stack, zo is er een asignement met meerdere identifiers mogelijk.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
foo := 7*6;
foo := bar := 7*6;
\end{lstlisting}

\subsection{Expressies - OR}
De Of-operator is de laagste operator in het rijtje, vandaar dat deze bovenin de structuur zit.
\\
NB: expr\_al1 staat voor "expression arithmetic level 1"
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={159-165}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Als expr\_al1 enkel uit 1 expr\_al2 bestaat dan zijn er geen restricties
\item In de andere gevallen dienen alle expr\_al2 van het type boolean te zijn.
\item het type van expr\_arithmetic is het type van expr\_al1
\item als exp\_1 == expr\_al2 dan is het type van expr\_al1 het type van expr\_al2
\item als exp\_1 != expr\_al2 dan is het type van expr\_al1 een boolean
\end{itemize}
\subsubsection{Semantiek}
De eerste expr\_al2 zal op de stack worden gezet. Hierna wordt er telkens een expr\_al2 erbij gezet. De OR-operatie zal worden aangeroepen en het resultaat blijft op de stack zijn. Als er nog een expr\_al2 is dan zal deze ook op de stack worden gezet en wordt de OR-operatie opnieuw aangeroepen. Aldoende blijft er uiteindelijk 1 waarde op de stack staan.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
true || false;
true || false || foo;
\end{lstlisting}

\subsection{Expressies - AND}
Hier wordt de AND-expressie beschreven. Net zoals bij de OR-expressie is het mogelijk nul tot veel AND-operatoren achter elkaar te plakken. De AND-expressie is een niveau hoger dan de OR-expressie en zal dus eerder worden uitgevoerd. \\
Het is eventueel mogelijk later in de compiler om een AND eerder af te breken aangezien als er een false in het rijtje zit het resultaat altijd false is. Wij hebben deze optimalisatie er nog niet inzitten, dit omdat sommige expressies ongeacht de eerdere expressies uitgevoerd dienen te worden, denk bijvoorbeeld aan een READ()-statement dat anders niet uitgevoerd zou worden.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={167-169}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Als expr\_al2 enkel uit 1 expr\_al3 bestaat dan zijn er geen restricties
\item In de andere gevallen dienen alle expr\_al3 van het type boolean te zijn.
\item als exp\_2 == expr\_al3 dan is het type van expr\_al2 het type van expr\_al3
\item als exp\_2 != expr\_al3 dan is het type van expr\_al2 een boolean
\end{itemize}
\subsubsection{Semantiek}
Hetzelfde als bij het OR-statement. De waardes zullen op de stack geladen worden en er zal telkens een AND-operatie op 2 waardes worden uitgevoerd. De resulterende waarde is weer geschikt voor bijvoorbeeld nog een AND-operatie.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
7*6;
foo && bar;
foo && false && bar;
\end{lstlisting}

\subsection{Expressies - Relaties}
Hier worden bijna alle comperatoren afgehandeld. Het is belangrijk dat er in de checker goed wordt gekeken of de types van de linker en rechterzijde compatible zijn.
\subsubsection{Syntax}
%		: expr_al4 ((RELS|RELSE|RELG|RELGE|RELE|RELNE)^ expr_al4)*
\lstinputlisting[style=ANTLR,linerange={171-173}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item alle expr\_al4 dienen van hetzelfde type te zijn
\item bij een operatie tussen twee expr\_al4 anders dan RELE \& RELNE dient expr\_al4 een integer te zijn.
\item als exp\_3 == expr\_al4 dan is het type van expr\_al3 het type van expr\_al4
\item als exp\_3 != expr\_al4 dan is het type van expr\_al3 een boolean
\end{itemize}
\subsubsection{Semantiek}
Vergelijkbaar met andere binaire operatoren zoals AND en OR, er zullen waardes op de stack worden gezet en de operatie zal 1 waarde achterlaten op de stack.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
5 > 6;
true == false;
5 == 42;
\end{lstlisting}

\subsection{Expressies - plus en minus}
Hier zijn we aangeland bij de eerder genoemde 6+3*12, plus en minus zit 1 niveau lager dan de vermenigvuldigingen.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={175-177}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item als er minimaal 1 operatie wordt uitgevoerd dan dient expr\_al5 een integer te zijn
\item als exp\_4 == expr\_al5 dan is het type van expr\_al4 het type van expr\_al5
\item als exp\_4 != expr\_al5 dan is het type van expr\_al4 een integer
\end{itemize}
\subsubsection{Semantiek}
Wederom een binaire operatie. Let op, de unaire plus en minus komen nog. Dus 5 - - 6 zal de tweede minus niet hier worde opgevangen.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo := 5;
foo := 5 + 37;
10 + 50 - 18;
\end{lstlisting}

\subsection{Expressies - delen en vermenigvuldigen}
Naast delen en vermenigvuldigen is het ook mogelijk een modulus te nemen.
Wat wellicht is opgevallen bij het bovenstaande, is dat het mogelijk is om enkel een som in de code te zetten. Dit vinden wij prima, echter moet daarbij wel de resulterende waarde gepopped worden als die niet meer gebruikt wordt.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={179-181}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item als er minimaal 1 operatie wordt uitgevoerd dan dient expr\_al6 een integer te zijn
\item als exp\_5 == expr\_al6 dan is het type van expr\_al5 het type van expr\_al6
\item als exp\_5 != expr\_al6 dan is het type van expr\_al5 een integer
\end{itemize}
\subsubsection{Semantiek}
Hetzelfde als bij optellen. Goed om te weten is dat de geretouneerde waarde een integer is, dus er zal worden afgerond.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo := 6;
foo := 6*7;
foo := 21*6%84;
\end{lstlisting}


\subsection{Expressies - unaries}
Hier wordt gekeken of de expressie eventueel een NOT-, PLUS- of MIN-operator voor zich heeft staan.
Om later verwarring te voorkomen zullen PLUS en MIN vervangen worden door speciale terminals, zijnde UMIN en UPLUS. UPLUS zou eventueel weg kunnen worden gelaten aangezien +x==x.
Als er geen operator voor de expressie staat dan is expr\_al6 gewoon een expr\_al7
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={183-191}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_al7 dient bij PLUS expr\_al7 een integer te zijn
\item expr\_al7 dient bij MIN expr\_al7 een integer te zijn
\item expr\_al7 dient bij NOT expr\_al7 een boolean te zijn
\item het type van expr\_al6 het type van expr\_al7
\end{itemize}
\subsubsection{Semantiek}
Bij UMIN zal expr\_al6 == - expr\_al7 \\
Bij UPLUS zal expr\_al6 == expr\_al7 \\
Bij NOT zal expr\_al6 == ! expr\_al7
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
one := +1;
evil := -42;
foo := ! foobar;
\end{lstlisting}

\subsection{Expressies - toplevel}
Op het hoogste nivau kan een expressie bestaan uit een semi-statement zoals een if-expressie of een print-expressie, of het kan een identifier of waarde zijn, of het kan een aparte (compound)expressie binnen haken zijn.
Zoals je ziet stond in eerste de assignment hier. Maar aangezien het meest linkerdeel van een assignment een identiefier is kan op lL(1) geen onderscheid worden gemaakt tussen identifier of een assignment. Vandaar dat een assignment bij expr\_al1 is gedefineerd.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={193-204}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item expr\_al7 is van hetzelfde type als de gegeven expressie of waarde.
\end{itemize}
\subsubsection{Semantiek}
Dit is enkel een lijst van mogelijke expressies en waardes en dus zal er in de compiler enkel deze expressie of waarde op stack hebben staan, maar wordt er geen operatie op uitgevoerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
foo;
42;
(foobar);
\end{lstlisting}

\subsection{Unsigned constants}
Uiteraard bied onze taal ook de mogelijkheid aan om constanten te gebruiken zonder deze eerst te moeten declareren. Oftewel, je kunt gewoon nummers gebruiken bijvoorbeeld.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={244-260,266-268}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item unsignedconstant is van het type van de gegeven waarde
\item boolval is een boolean type
\item charval is een char
\item intval is een integer
\end{itemize}
\subsubsection{Semantiek}
De desbetreffende waarde wordt op de stack gezet.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
'Y';
42;
true;
\end{lstlisting}

\subsection{Identifier}
Een identifier van een bestaande variabele of constante in de huidige of een hogere scope.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={261-264,275-277}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De identifier dient te verwijzen naar een geldige variabele of constante
\item Het type is het type van de variabele of declaratie waar de identifier naar verwijst.
\end{itemize}
\subsubsection{Semantiek}
Er zal een commando aangeroepen worden om de waarde uit het geheugen te laden. Deze waarde wordt dan op de stack gezet. Bij constanten gebeurd dit ook. Eventueel zou je ook de constante zelf al kunnen neerzetten op de stack, dit scheelt weer wat werk voor de processor. Dit doen wij echter niet momenteel. - Last minute update - Nu doen wij dat wel, constanten zullen direct uit de symboltable getrokken worden.
/todo{Mark}
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
Answer42;
\end{lstlisting}

\subsection{Read}
Om contact te hebben met de buitenwereld kan onze taal lezen en schrijven naar de standard-out.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={205-207}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Identifier dient te verwijzen naar een geldige identifier
\item De ingelezen waarde dient van het zelfde type als identifier te zijn
\item Als er 1 identifier is opgegeven dan geeft read de gelezen waarde/type terug
\item Als er meer dan 1 identifier wordt ingelezen dan is het returntype void
\end{itemize}
\subsubsection{Semantiek}
Het read-commando wordt aangeroepen en de waarde wordt van de standard-out gelezen en op de stack gezet. Vervolgens wordt die waarde opgeslagen in de variabele.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
read(foo);
read(foo,bar);
\end{lstlisting}

\subsection{Print}
De taal heeft ook de mogelijkheid om dat wat er bijvoorbeeld berekend is naar buiten te communiceren.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={209-212}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item -
\end{itemize}
\subsubsection{Semantiek}
De waarde van de expressie staat op de stack. Vervolgens wordt deze netjes naar het scherm uitgevoerd. Afhankelijk van het type zal dat anders gebeuren.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
print(42);
print('4','2');
\end{lstlisting}

\subsection{If}
Om keuzes in het programma mogelijk te maken zal er een conditioneel statement nodig zijn, het IF-statement is een dergelijk statement. Een ELSE-deel is optioneel.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={213-215}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De eerste compoundexpression moet een boolean-type retouneren
\item De if retouneerd de waarde en type van de expressie die wordt uitgevoerd. (na de then of else)
\item De if retouneerd void als er geen expressie wordt uitgevoerd.
\end{itemize}
\subsubsection{Semantiek}
Als de waarde binnen het ifstatement waar is dan zal de eerste compoundexpressie worden uitgevoerd (na de then). Anders zal de andere compoundexpressie worden uitgevoerd, mits deze is gedeclareerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
if true; then i := 42; fi;
if false; then i := 0; else i:=42; fi;
\end{lstlisting}

\subsection{While}
De while zal net zolang een blok code uitvoeren tot een gegeven expressie waar is.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={217-219}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De eerste compoundexpression moet een boolean-type retouneren
\item De while retouneerd een type void
\end{itemize}
\subsubsection{Semantiek}
De tweede compoundexpression zal worden uitgevoerd tot de eerste compoundexpression waar is. Het kan zijn dat de tweede compoundexpression nooit wordt uitgevoerd dus.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
while false; do
\\ this is not gonna be executed
tru := false;
od;

while foo<5; do
foo := foo + 1;
od;
\end{lstlisting}

\subsection{Functieaanroep}
Een functieaanroep naar een eerder gedefineerde functie
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={221-223}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item Het aantal expressies en hun type dient overeen te komen met de declaratie van de functie
\item De functie retouneert het eerder gespecificeerde type. Als er geen type was gedeclareerd dan is dat dus void.
\end{itemize}
\subsubsection{Semantiek}
Het returnadres wordt op de stack gezet, zodat de functie weer hiernaartoe kan terugkeren.
De expressies worden op de stack gezet in de gespecificeerde volgorde.
De functie wordt aangeroepen.
De functie returned en het result staat op de stack.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
@foo();
i := @foo('b','a','r',);
\end{lstlisting}


\subsection{Closed expression}
Een expressie tussen haakjes is soms handig, bijvoorbeeld bij sommetjes: (5+2)*6;
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={229-231}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item De geretouneerde waarde zal de waarde van de expressie zijn binnen de haakjes.
\item Het retourneerde type is ook hetzelfde als die van de expressie.
\end{itemize}
\subsubsection{Semantiek}
De expressie binnen de haakjes zal worden uitgevoerd binnen de haakjes.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
(3*(6+8))%102;
\end{lstlisting}

\subsection{Closed compoundexpression}
Is een compoundexpressie binnen haakjes. Verschil met de expressie tussen haakjes is dat deze ook toestaat om declaraties te gebruiken. Een compound tussen haakjes zal een eigen scope hebben.
\subsubsection{Syntax}
\lstinputlisting[style=ANTLR,linerange={225-227}]{../g-files/SELMA.g}
\subsubsection{Context}
\begin{itemize}
\item retouneerd het waarde en de type van de laatste expressie in de compound, dit kan van het type void zijn.
\end{itemize}
\subsubsection{Semantiek}
De compoundexpressie zal in een eigen scope worden uitgevoerd.
\subsubsection{Voorbeeld}
\begin{lstlisting}[style=SELMA]
{
var foo: integer;
foo := 40;
foo+2;
};
\end{lstlisting}



%
%expression_statement
%	: expression SEMICOLON
%		-> ^(EXPRESSION_STATEMENT expression)
%	;
%


%==================================OPMAAK======================================

%\subsection{Expressies - }
%
%\subsubsection{Syntax}
%\lstinputlisting[style=ANTLR,linerange={131-137}]{../g-files/SELMA.g}
%\subsubsection{Context}
%\begin{itemize}
%\item
%\end{itemize}
%\subsubsection{Semantiek}
%
%\subsubsection{Voorbeeld}
%\begin{lstlisting}[style=SELMA]
%\end{lstlisting}

%==================================OPMAAK======================================

\newpage
\section{Vertaalregels}
Deze sectie specificeerd hoe selma programmas naar Jasmin worden vertaald. Jasmin is een assembler die gegeven Jasmin assembly JVM bytecode genereerd in de vorm van een \texttt{.class} file.

De vertaling wordt gedaan door middel van een compiler (g-files/SELMACompiler.g) in ANTLR die executeerd na de checker en producties uit de Jasmin string template aanroept (SELMACodeJasmin.stg).

We gebruiken de volgende code functies:

\begin{itemize}
    \item run       : Program     $\rightarrow$ Instruction*
    \item execute   : ExpressionStatement $\rightarrow$ Instruction*
    \item evaluate  : Expression  $\rightarrow$ Instruction*
    \item elaborate : Declaration $\rightarrow$ Instruction*
\end{itemize}

\begin{tabular}{| l | c | l |}
  \hline
  Phase   & Code Function & Effect \\
  \hline \hline
  Program & run P       & Run P en begin en eindig met een lege stack. Doe ook de \\
  &&                      nodige declaraties om classen en methoden te genereren. \\
  &&											 Return hierna.\\
  \hline
  ExprStat & execute S  & Executeer statement S. Als S een expressie is dat \\
  && 										 een waarde op de stack genereerd, pop. Dit veranderd de \\
  &&											 stack niet. \\
  \hline
  Expression & evaluate E & Evalueer expressie E en laat de nieuwe waarde op de stack staan.\\
  &&												 Een expressie kan 1 of 2 oude waarden van de stack halen (e.g. AND). \\
  \hline
  Declaration & elaborate & Behandel een declaratie voor constanten, variabelen en functies.\\
  &&                        Dit maakt entries aan in de symbol table en genereerd simpele \\
  &&                        declaratie code zoals methoden en velden.\\
  \hline
\end{tabular}
\\
In onze vertaalregels zullen we variabelen omringen met \textless en \textgreater. Soms zijn er hulpvariabelen nodig die geen deel uitmaken van de syntax. We zullen dit aanduiden als extra argumenten aan de code function, e.g. \texttt{evaluate[ID := E, is\_global, type]}, waarbij \texttt{is\_global} en \texttt{type} extra argumenten zijn die geen deel uitmaken van de syntax maar van de context.\\

\subsection{Run}
\subsubsection{Program}
\lstinputlisting[style=ANTLR,linerange={122-122,131-134}]{../g-files/SELMACodeJasmin.stg}
\begin{verbatim}
run[P, source_file, stack_limit, locals_limit, pop] =
	  .source <source_file>
	  .class public Main
	  .super java/lang/Object
	  .field public static scanner_field Ljava/Util/Scanner;

	  .method public static main([Ljava/lang/String;)V
	  .limit stack <stack_limit>
	  .limit locals <locals_limit>
    new java/util/Scanner
    dup
    getstatic java/lang/System/in Ljava/io/InputStream;
    invokespecial java/util/Scanner/<init>(Ljava/io/InputStream;)V
    putstatic Main/scanner_field Ljava/util/Scanner;

    evaluate[P]
    if <pop>:
        pop

    return
.end method
\end{verbatim}

De \texttt{source\_file}, \texttt{stack\_limit} en \texttt{locals\_limit} geven respectievelijk aan wat de originele source file was (voor runtime excepties), de grootte van de stack en het aantal locale variabelen dat het programma gebruikt. \texttt{pop} geeft aan of P een expressie was en nog een waarde op de stack heeft achtergelaten. Dit zou ook opgelost kunnen worden door de regel

\begin{verbatim}
    program -> expression_statement
    expression_statement -> expression
    expression -> ... | compoundexpression
    compoundexpression -> (declaration | expression_statement)*
\end{verbatim}

in plaats van

\begin{verbatim}
    program -> compoundexpression
\end{verbatim}

Helaas resulteerd dit in Left Recursion waar we geen tijd meer voor hadden dit op te lossen. Een simpele \texttt{pop = expression.type != type.VOID} lost dit echter gauw genoeg op.\\
\\
Als er labels in code regels voorkomen als L1, L2, etc, zullen deze in werkelijkheid uniek genummerd zijn.

\subsection{Execute}
\subsubsection{ExpressionStatement}

\begin{verbatim}
execute[S, pop] =
    evaluate[S]
    if pop:
        pop
\end{verbatim}

\texttt{S} is hierbij een expressie en pop is wederom true iff \texttt{expression.type != type.VOID}.

\subsubsection{while}
\begin{verbatim}
execute[while E; do S; od] =
    L1:
        evaluate[E]
        ifeq	 L2
        execute[S]
        goto L1
    L2:
\end{verbatim}

De \texttt{ifeq} instructie kijkt of de waarde op de top van de stack gelijk is aan 0 (boolean waarden zijn integer waarden 0 of 1), en als dat het geval is jumpt de interpreter naar de label L2 (naar de eerstvolgende instructie na de while loop). Als dit niet het geval is gaat hij verder met de eerste instructie van \texttt{S} en hierna volgt een jump naar het begin om te kijken of een volgende iteratie nodig is.

\subsection{Evaluate}
\subsubsection{Compound Expression}
Omdat een compound expression ook weer een expressie is, maar bestaat uit expressie statements, moet de codegenerator de mogelijk gegenereerde pop van de laatste expressie statement verwijderen. De regel is als volgt:

\begin{verbatim}
compoundexpression = COMPOUND (declaration | expression_statement)*

evaluate[E, last_expr_is_void] =
    evaluate[E]
    if not <last_expr_is_void>:
    	    remove_last_instruction
\end{verbatim}

Hier geeft de variabele \texttt{last\_expr\_is\_void} aan of de laatste expressie (als er tenminste 1 expressie is) van type VOID is. Als dit niet het geval is, is er een pop gegenereerd door \texttt{expression\_statement} die verwijderd moet worden. Dit gebeurt door een dummy instructie \texttt{remove\_last\_instruction} te genereren die de laaste instructie verwijderd. Dit gebeurd voordat mhet resultaat naar een Jasmin aseembly file geschreven wordt.

\subsubsection{if then else expression}

\begin{verbatim}
evaluate[if E1 then E2 (else E3)?] =
        evaluate[E1]
        ifeq L1
        evaluate[E2]
        goto L2
    L1:
        evaluate[E3]
    L2:
\end{verbatim}

\subsubsection{Identifier}
\label{Identifier}

\begin{verbatim}
evaluate[ID, kind, is_global, type] =
    if kind == CONST:
        ldc getvalue(<ID>)
    else if is_global:
        getstatic Main/<ID> <type>
    else:
        iload address_of(<ID>)
\end{verbatim}

Als de variabele een constante is wordt de waarde bijgehouden in de symbol table. De functie \texttt{getvalue} haalt hier de waarde van de constante op.
\texttt{address\_of} is hier een functie die gegeven een identifier zijn address als locale variabele ophaalt. Als de waarde een globale variabele is, is het een field zodat functies beschikking hebben tot deze variabele (als het een locale variabele in de statische \texttt{main} functie zou zijn zou dit niet het geval zijn). In dit geval is de \texttt{is\_global} boolean true en is \texttt{type} het type van de variabele.

\subsubsection{Integer Literal}
\begin{verbatim}
evaluate[literal, iconst, bipush, ldc] =
    if iconst:
        iconst_<literal>
    elif bipush:
        bipush <literal>
    else:
        ldc <literal>
\end{verbatim}

Als de integer literal in de juiste range van iconst of bipush zit, worden deze geprefereerd over ldc voor compactere bytecode.

\subsubsection{Character Literal}
\begin{verbatim}
evaluate[literal] =
    bipush <literal>
\end{verbatim}

\subsubsection{Boolean Literals}
\begin{verbatim}
evaluate[true] =
    iconst_1
\end{verbatim}

en

\begin{verbatim}
evaluate[false] =
    iconst_0
\end{verbatim}

\subsubsection{Arithmetic, AND en OR}
\begin{verbatim}
evaluate[E1, op, E2, instruction] =
    evaluate[E1]
    evaluate[E2]
    <instruction>		; E1 <op> E2
\end{verbatim}

Hierbij is op een binaire arithmetic operator zoals \texttt{+}, \texttt{-}, etc, of AND/OR. \texttt{instruction} is de bijbehorende JVM Jasmin instructie. De operators mappen als volgt naar hun instructies:

\begin{itemize}
	\item \texttt{+} : \texttt{iadd}
	\item \texttt{-} : \texttt{isub}
	\item \texttt{*} : \texttt{imul}
	\item \texttt{/} : \texttt{idiv}
	\item \texttt{\%} : \texttt{irem}

	\item \texttt{\&\&} : \texttt{iand}
	\item || : \texttt{ior}
\end{itemize}

\subsubsection{Relational operators}

\begin{verbatim}
evaluate[E1 op E2, instruction] =
    evaluate[E1]
    evaluate[E2]
    <instruction> L1	  ; E1 <op> E2
    iconst_0
    goto L2
L1:
    iconst_1
L2:
\end{verbatim}

Voor elke relational relational operator zoals \texttt{\textless=}, \texttt{==} etc wordt deze code gegenereerd met bijbehorende instructie. De opererator naar instructie mapping is als volgt:

\begin{verbatim}
	<  : ifcmp_lt
	<= : ifcmp_le
	== : ifcmp_eq
	!= : ifcmp_ne
	>= : ifcmp_ge
	>  : ifcmp_gt
\end{verbatim}

\subsubsection{Unary Plus and Minus}
\begin{verbatim}
evaluate[-E] =
    evaluate[E]
    ineg
\end{verbatim}

Voor unary \texttt{+} hoeft er niets te gebeuren.

\subsubsection{NOT}
\begin{verbatim}
evaluate[!E] =
    evaluate[E]
    ifeq L1
    iconst_0
    goto L2
L1:
    iconst_1
L2:
\end{verbatim}

\subsubsection{Assignment}
\begin{verbatim}
evaluate[ID := E, is_global, type] =
    evaluate[E]
    dup
    if is_global:
        putstatic Main/<ID> <type>
    else:
        istore address_of(<ID>)
\end{verbatim}

\texttt{address\_of} is hier een functie die gegeven een identifier zijn address als locale variabele ophaalt. De boolean \texttt{is\_global} geeft aan of de variabele een globale variabele variabele is (in welk geval het een statisch veld is van de \texttt{Main} class). \texttt{type} geeft vervolgens aan van welk type dit veld (de variabele) is. De \texttt{dup} is nodig om de waarde eerst te dupliceren aangezien assignment een expressie is.

\subsubsection{Print}
\begin{verbatim}
evaluate[print(E+), type_denoters, bools, dup_top] =
    for expr, type_denoter, is_bool in E, type_denoters, bools:
        evaluate[expr]

        if <dup_top>:
            dup

        if <is_bool>:
                ifeq L1
                ldc "true"
                goto L2
            L1:
                ldc "false"
            L2:

        getstatic java/lang/System/out Ljava/io/PrintStream;
        swap
        invokevirtual java/io/PrintStream/println(<type_denoter>)V
\end{verbatim}

Hier krijgt de vertaalregel voor elke expressie mee of het type \texttt{boolean} is (\texttt{bools}), en welke overloaded versie van \texttt{System.out.println} moet worden aangeroepen (\texttt{type\_denoters}). In het geval van een boolean moet de waarde \texttt{"true"} of \texttt{"false"} worden geladen in plaats van de integer waarde. De boolean dup\_top geeft aan of de print een statement of expressie is. Als het een expressie is (in het geval van een enkele print), moet de waarde worden gedupliceerd op de stack voordat de println de waarde popt.

\subsubsection{Read}
\begin{verbatim}
evaluate[read(ID+), bools, ints, dup_top] =
    for id, is_bool, is_int in ID, bools, ints:
		    getstatic Main/scanner_field Ljava/util/Scanner;

        if <is_bool>:
            invokevirtual java/util/Scanner/nextBoolean()Z
        elif <is_int>:
            invokevirtual java/util/Scanner/nextInt()I
        else:
            invokevirtual java/util/Scanner/nextByte()I

        if <dup_top>:
            dup

                evaluate[ID := top of stack]
\end{verbatim}

Hier krijgt de vertaalregel voor elke expressie mee of het type \texttt{boolean} of int is (\texttt{bools}, texttt{ints}) en of de read een expressie is (\texttt{dup\_top}). \texttt{address\_of} is hier een functie die gegeven een identifier zijn address als locale variabele ophaalt. Afhankelijk van het type (boolean, integer of character) wordt een aanroep gedaan naar de methoden nextBoolean(), nextInt() of nextByte() van Scanner.

\subsubsection{Function Call}
\begin{verbatim}
evaluate[FUNCCALL ID (expr)*, param_types, return_type] =
    for each expr:
        evaluate[expr]
    invokestatic Main/<ID>(<param_type> for param_type in <param_types>)<return_type>
 \end{verbatim}

We evalueren eerst alle argumenten (\texttt{expr}), waarna we een statische aanroep doen naar de methode in \texttt{Main} met de naam van de functie aanroep. \texttt{param\_types} zijn de typen van de parameters van de functie en \texttt{return\_type} is het return type van de functie.

\subsection{Elaborate}
De elaborate code functie handeld declaraties af van constanten en variabelen en van functie definities. In elk geval worden er symbol table entries aangemaakt. In het geval van constanten wordt er geen code gegenereerd, maar wordt de constante waarde onthouden in de symbol table.

\subsubsection{Variabelen en Constanten}
\begin{verbatim}
elaborate[VarDeclaration type ID] =
    increase amount of local variables by one
    entry = enter <ID> of <type> and kind VAR in symbol table
    if entry.level == 0:
       ; global scope, declare field
        .field public static <ID> <type>
    else:
        increase amount of local variables by one

elaborate[ConstDeclaration type ID value] =
    increase amount of local variables by one
    enter <ID> of <type> and kind CONST in symbol table
    set value on symbol table entry of <ID>
\end{verbatim}

\subsubsection{Function definition}
\begin{verbatim}
elaborate[FUNCTION ID (param_type param)* body (RETURN return_expr)? return_type] =
    enter <ID> of <type> and kind FUNC in symbol table

    .method public static <funcname>(<param_type for each param_type>)<return_type>
    .limit stack <stack_limit>
    .limit locals <locals_limit>
        execute[body]
        if <return_expr>:
            evaluate[return_expr]
            ireturn
        else:
            return
    .end method
\end{verbatim}

Hier is \texttt{ID} de naam van de functie, \texttt{param\_type} en \texttt{param} het type en naam van elke respectievelijke parameter, \texttt{body} de function body, de optionele \texttt{return\_expr} de expressie waarvan de waarde returned wordt, en \texttt{return\_type} het return type van de functie.
We genereren dus een statische methode, aangezien we de \texttt{Main} class nooit instantieren.
\\
Aangezien methoden niet gegeneerd kunnen worden in een andere methode, herschrijft onze "post-processor" methoden in methoden naar een lijst van methoden. i.e.

\begin{verbatim}
.method A
    .method B
        ...
    .end method
.end method
\end{verbatim}

wordt

\begin{verbatim}
.method A
    ...
.end method

.method B
    ...
.end method
\end{verbatim}

\newpage
\section{Beschrijving van Java programmatuur}
%Beknopte bespreking van de extra Java klassen die
%u gedefinieerd heeft voor uw compiler (b.v. symbol table management, type checking, code
%generatie, error handling, etc.). Geef ook aan welke informatie in de AST-nodes opgeslagen
%wordt.
%
%
%CheckerEntry.java    SELMA.java
%CompilerEntry.java   SELMATreeAdaptor.java
%IdEntry.java         SELMATree.java
%SELMAException.java  SymbolTable.java
\subsection{main - SELMA}
SELMA.java is het main-programma. Je kunt een aantal opties en een SELMA-sourcecodefile meegeven.
Hierna zal SELMA desbetreffende file parsen en compileren. De opties die mogelijk zijn zijn:
\begin{itemize}
\item -ast Er zal een ast-diagram naar de stdOut worden geprint van de source-code.
\item -dot Er zal een dot-diagram naar de stdOut worden geprint van de source-code.
\item -no\_checker De source-code wordt geparsed maar niet gechecked.
\item -code\_generator De source-code zal worden gecompiled
\end{itemize}
De sourcecode zal de volgende stappen doorlopen: \\
\begin{tabbing}
\hspace{5em}\=\hspace{5em}\=\hspace{7em}\=\hspace{5em}\=\hspace{10em}\=\kill
Lexer \>  Parser \> -no\_checker 	\>   		\> -ast \>  Ast-diagram \\
Lexer \>  Parser \> -no\_checker 	\>   		\> -dot \>  Dot-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -ast \>  Ast-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -dot \>  Dot-diagram \\
Lexer \>  Parser \>  				\>  Checker \> -code\_generator \>  Code
\end{tabbing}
Alle resultaten zullen altijd naar de stdOut worden geprint.

\subsection{SELMAException}
Als er wat fout gaat in bijvoorbeeld de checker dan zal er een exception worden gegooid. Deze exception is een SELMAException. Aan de exception wordt de node meegegeven waar de checker op dat moment mee bezig is. En de toString()-functie van SELMAException zal dat dan ook mooi formatten in de vorm van "(regelnummer:columnnummer) Errormessage", toch wel fijn als je moet debuggen.

\subsection{SELMATreeAdaptor}
Deze TreeAdaptor heeft SELMATree als nodes, in plaats van een normale Tree.

\subsection{SELMATree}
SELMATree is een uitbreiding op de normale tree. En kan een aantal extra dingen bijhouden, namelijk of een expressie constant is of variabel, wat later handig is voor optimizing. En wat het type is van de expressie, dat is zeer handig voor de checker.
Daarvoor heeft SELMATree een paar extra attributen, zijnde:
\lstinputlisting[style=JAVA,linerange={26-30}]{../src/SELMA/SELMATree.java}
En verder kent SELMATree nog drie functies om mooi te kunnen printen:
\lstinputlisting[style=JAVA,linerange={52-52,56-56,88-88}]{../src/SELMA/SELMATree.java}

\subsection{SymbolTable}
De symboltable houdt al onze variabelen en constanten bij. Ook kun je in de symboltable scopes aanmaken, om bijvoorbeeld variabelen binnen een compoundexpressie te kunnen declareren. De dataopslag van de symboltable geschiedt middels een Map waarin een string aan een stack van IDEntries wordt gekoppeld. De string verwijst naar de naam van de variabele of constante. De stack bevat meerdere declaraties van die variabele met die naam in verschillende scopes. Zodat het mogelijk is de zelfde naam tweemaal te gebruiken, mits ze in een andere scope gebruikt worden.\\
\\
De symboltable kent een aantal functies, de belangrijkste zijn:
\lstinputlisting[style=JAVA,linerange={28-32,36-42,58-66,88-94}]{../src/SELMA/SymbolTable.java}

\subsubsection{SymbolTableException}
SymbolTableException is er om fouten in de symboltable aan te geven. Deze fouten zullen vergelijkbaar worden geformat als die van SELMAException, namelijk "(line:column) ErrorMsg.

\subsection{IDEntry}
De symboltable bevat voor elke variabele of constante een IDEntry. Een IDEntry bevat de scopelevel van desbetreffende declaratie. Wij gebruiken in onze code echter een tweetal klasses die ge-extend zijn op IDEntry; CheckerEntry en CompilerEntry.

\subsection{CheckerEntry}
De CheckerEntry wordt gebruikt in de Checker. Een checkerEntry verschilt van een IDEntry op het punt dat een checkerEntry vier extra waardes heeft om bij te houden wat het type is van de variabele of constante (int,bool of char). De tweede waarde is om bij te houden of we met een constante of een variabele te maken hebben. Dan is er nog een variabel waar wordt onthouden of deze entry een functie is. En de vierde staan alle parameters va nde functie in.
\lstinputlisting[style=JAVA,linerange={24-31}]{../src/SELMA/CheckerEntry.java}

\subsection{CompilerEntry}
De compilerEntry is weer een uitbreiding op de CheckerEntry. Voor de compiler is het namelijk noodzakelijk om te weten op welk adres in de te genereren code de variabele staat en nog een aantal andere dingen. Dit wordt bijgehouden door:
\lstinputlisting[style=JAVA,linerange={11-18}]{../src/SELMA/CompilerEntry.java}

\newpage
\section{Testplan en -resultaten}
Voor het testen hebben we testprogramma's geschreven in onze taal. Ook zit er een testrunner bij die automatisch alle tests in de 'test' subdirectory vind en compileerd en optioneel executeerd.
Tests kunnen van de volgende typen zijn:
\begin{itemize}
	\item Compile - Compileer de test
	\item Error	    - Compileer en (als successvol), executeer
	\item Run		    - Compileer en executeer
\end{itemize}

Bij deze tests kunnen in het programma tags gezet worden, namelijk <input>text</input> voor input voor het programma op stdin, en <output>text</output> voor output van het programma (of de compiler, in het geval van een compile of error test). Error tests beginnen met de prefix 'error\_' in de bestandsnaam, en compile tests met 'compile\_'. Zo kan getest worden voor juiste syntax en semantiek, juiste error reporting bij onjuiste syntax en semantiek, en correctie vertaalregels door middel van correcte executie, en runtime error checking voor juiste programmas met runtime fouten. Om de tests te runnen is Python 2.5+ < 3.0 nodig. De tests kunnen als volgt worden geexecuteerd:

\begin{verbatim}
    $ python test.py
\end{verbatim}

of

\begin{verbatim}
    $ make tests
\end{verbatim}


Als een run test geen output heeft gespecificeerd is de exit status van het programma bepalend of de test faalt of niet. Bij een error test geldt het tegenovergestelde: zonder gespecificeerde output moet de exit status nonzero zijn.

De tests in de test directory testen alle constructen uit de taal, zoals arithmetic, alle operators, typen, constanten, scope rules, etcetera. Hieronder is output gegeven van de test runner. Als een test faalt zal de output worden weergegeven:

\begin{lstlisting}[style=SELMA]
[0] [11:11] ~/selma git(master!) ➤ python test.py
Run        test/correct.selma                                 ...  OK
Error      test/error_compiletime_uninitialized.selma         ...  OK
Error      test/error_context.selma                           ...  OK
Error      test/error_if.selma                                ...  OK
Error      test/error_pasen_string.selma                      ...  OK
Error      test/error_runtime_uninitialized.selma             ...  OK
Error      test/error_runtime_zerodivision.selma              ...  OK
Error      test/error_syntax.selma                            ...  OK
Error      test/error_while.selma                             ...  OK
Error      test/error_while_void.selma                        ...  OK
Run        test/sample.selma                                  ...  FAIL (exit status 0)
  Got:
        h
    >>> a
        l
        l
        o
  Expected:
        h
    >>> e
        l
        l
        o
--------------------------------------------------------------------------------
Run        test/test_if.selma                                 ...  OK
Run        test/test_operators.selma                          ...  OK
Run        test/test_pasen.selma                              ...  OK
Run        test/test_pasen_-5.selma                           ...  OK
Run        test/test_pasen_3000.selma                         ...  OK
Run        test/test_while.selma                              ...  OK
Run        test/test_functions/correct_functions.SELMA        ...  OK
Error      test/test_functions/error_doublefunction.selma     ...  OK
Error      test/test_functions/error_nested.selma             ...  OK
Error      test/test_functions/error_wrongparamcount.selma    ...  OK
Error      test/test_functions/error_wrongparamtype.selma     ...  OK
Error      test/test_functions/error_wrongreturntype.selma    ...  OK
Run        test/test_functions/recursion.selma                ...  OK
Ran 24 test(s), SUCCESS=23, FAILURE=1

\end{lstlisting}

Hier zien we dat \texttt{test/sample.selma} niet de correcte output heeft, maar wel executeerde zonder fouten (exit status 0), terwijl \texttt{test/test\_functions/correct\_functions.SELMA} een compilatie fout had met een exit status 1. De eerste colom geeft het type test aan, in dit geval 'Error' of 'Run'. Ter demonstratie is \texttt{test/sample.selma} bijgevoegd:


\begin{lstlisting}[style=SELMA]
<output>
    h
    e
    l
    l
    o
</output>
print('h', 'a', 'l', 'l', 'o');
\end{lstlisting}

\subsection{Pasen}
Het grootste testprogramma heet pasen, deze wordt ook meegenomen in de test. Pasen berekent middels het algorithme van Gauss wanneer pasen valt in een gegeven jaar. \\
De SELMA-code is goed gedocumenteerd. De rekenstappen zijn soms wat omslachtig geschreven om gebruik te maken van alle mogelijkheden van de taal.\\
In de appendix is de code te vinden van pasen, zowel in SELMA als Jasmin.\\
De testrunner ondersteund alleen een enkele input en een enkele output. Om een programma makkelijk en snel te testen met verschillende in- en outputs hebben we ook wel commandos als het volgende gebruikt:

\begin{verbatim}
	sh selma test/test_pasen.selma <<< 2011
\end{verbatim}

Op deze manier kunnen tests in de test directory overigens ook getest worden, als de \texttt{input} en \texttt{output} tags in SELMA comments staan (hetgeen het geval is voor de meeste tests).\\

Tenslotte is de output van een testrun van \texttt{test.py} opgeslagen in \texttt{output.testrun}


\newpage
\section{Conclusies}
We hebben een taal gedefineerd, uitgeschreven, regels aan toegevoegd en dit omgezet naar een stuk Jasmin. Zonder ons in al te veel bochten te moeten wringen om de taal werkend te krijgen of binnen de LL(1) restrictie zien te krijgen. \\
Tot zover lijkt ons dat het over het algemeen wel goed gegaan is - begrijp ons niet verkeerd, we hadden graag nog arrays geimplementeerd - maar we hebben een werkende taal, welke niet aan elkaar geplakt zit van de lelijke oplossingen. \\
\\
We hebben zeker 40 pagina's verslaglegging (met appendices 100+). Waarin we hebben geprobeerd alles uit te leggen, hier en daar op een wat informele toon, maar we weten wie het leest. En om de lezer continu met 'u' aan te spreken - en geen kleine grapjes te kunnen maken - is het wel een erg droog verslag om te lezen.\\
\\
Het had ons persoonlijk erg leuk geleken om een optimizer te schrijven, dit is echter nogal wat werk en we zijn daar niet aan toegekomen. Bovendien dienen we aan de boekhouding te denken, in het verslag stond niet duidelijk of dat ons pluspunten zou opleveren.
De uitdaging aan de optimizer was denk ik het puzzelen geweest, om net overal de code net iets vlotter te maken. Zo is er bijvoorbeeld al rekening gehouden door van elke expressie bij te houden of deze variabele onderdelenbevat, als een expressie compleet constant zou zijn dan zou je immers het net zo goed een maal kunnen uitrekenen en als dergelijk in de code te zetten.\\
\\
Verder hadden nog leuke dingen toegevoegd kunnen worden aan de taal, die wellicht niet allen even makkelijk zijn met de JVM, maar wel uitdagend. Vooral generators en closures zouden leuk geweest zijn. En de taal heeft erg weinig typen, het zou leuk zijn als de taal toestaat Java classen te importeren en vrij te gebruiken. Ook \texttt{try/catch} en \texttt{try/finally} zouden een meest welkome additie zijn geweest.

\newpage
\section{Appendix}

\subsection{ANTLR Lexer \& Parser specificatie}
%Specificatie van de invoer voor de ANTLR scanner generator,
%d.w.z. de token-definities van het taaltje.

%Specificatie van de invoer voor de parser generator, d.w.z. de
%structuur van de taal en de wijze waarop de AST gegenereerd wordt
\lstinputlisting[style=ANTLRfile]{../g-files/SELMA.g}

\newpage
\subsection{ANTLR Checker specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMAChecker.g}

\newpage
\subsection{ANTLR Codegenerator specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMACompiler.g}

\begin{landscape}
\newpage
\subsection{ANTLR Codegenerator Stringtemplate specificatie}
%Waarschijnlijk zult u (tenminste) twee tree parsers
%gebruiken: een context checker en een code generator.
\lstinputlisting[style=ANTLRfile]{../g-files/SELMACodeJasmin.stg}
\end{landscape}

\newpage
\subsection{Invoer- en uitvoer van een uitgebreid testprogramma}
%Van een correct en uitgebreid test-
%programma (met daarin alle features van uw programmeertaal) moet worden bijgevoegd: de
%listing van het oorspronkelijk programma, de listing van de gegenereerde TAM-code (be-
%standsnaam met extensie .tam) en een of meer executie voorbeelden met in- en uitvoer
%waaruit de juiste werking van de gegenereerde code blijkt.
De code van pasen.

\subsubsection{SELMA-code van pasen}
\lstinputlisting[style=SELMAfile]{../test/test_pasen.selma}

\newpage
\begin{landscape}
\subsubsection{Jasmin-code van pasen}
\lstinputlisting[style=JVMfile]{../test/test_pasen.jasmin}
\end{landscape}

\end{document}
