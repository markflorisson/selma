//SELMA string template

group SELMA;

program(instructions, source_file) ::= <<
.source <source_file>
<instructions>
HALT
									; end of program
>>

compound(instructions) ::= <<
									; start compound
<instructions; separator="\n">
									; end compound
>>


//Calculations
Expr(e1,op)::=<<
<e1>								; e1 for operation <op>
CALL <op>							; single operation <op>
>>

biExpr(e1,e2,op)::=<<
<e1>								; e1 for operation <op>
<e2>								; e2 for operation <op>
CALL <op>									; binary operation <op>
>>

//Declare
declareConst(id,val,type,addr)::=<<
									; declare var <id>: <type> = <val> @ <addr>[SB]
ldc <val>                           ; declare var
>>

declareVar(id,type,addr)::=<<
									; declare var <id>: <type> @ <addr>[SB]
PUSH 1
>>

//Load

loadNum(val, num)::=<<
    <if (iconst)>
        iconst_<val>
    <elseif (bipush)>
        bipush <val>
    <else>
        ldc <val>
    <endif>
>>

loadVal(id,addr)::=<<
									; loadVal <id> from <addr>[SB]
iload <addr>                        ; load integer from <addr>
>>

//Assign
assign(id, type, addr, e1, isint)::=<<
    ; todo: match on node type and do assignNum, assignRef etc
    <e1>								; e1 right hand for assignment
    istore <addr>                       ; assign e1 to <id>: <type> @ <addr>[SB]
    <endif>
>>

//conditionals
if(ec1, ec2, ec3)::=<<
<ec1>								; e1 condition
ifcmp L1                            ; e1 is false
<ec2>								; e2 if true expression
goto L2
L1:
<ec3>								; e3 if false expression
L2:
>>

while(ec1,ec2)::=<<
<ec1>								; e1 while condition
<ec2>								; e2 expression to evaluate
hier hoort een while
>>
